<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Blog of WenXinLin">
<meta property="og:url" content="http://example.com/landscape/index.html">
<meta property="og:site_name" content="Blog of WenXinLin">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="LinWenXin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/landscape/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Blog of WenXinLin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog of WenXinLin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">11</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/29/Deauth%E6%8A%A5%E6%96%87%E7%9A%84ReasonCode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/myicon.jpg">
      <meta itemprop="name" content="LinWenXin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of WenXinLin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/29/Deauth%E6%8A%A5%E6%96%87%E7%9A%84ReasonCode/" class="post-title-link" itemprop="url">无线协议规定的802.11 Deauth报文的Reason Code</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-29 20:43:36" itemprop="dateCreated datePublished" datetime="2024-07-29T20:43:36+08:00">2024-07-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Code-Reason："><a href="#Code-Reason：" class="headerlink" title="Code Reason："></a>Code Reason：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">0 Reserved</span><br><span class="line">1 Unspecific Reason</span><br><span class="line">2 Previous authentication no longer valid</span><br><span class="line">3 Deauthenticated because sending STA is leaving (or has left) IBSS or ESS</span><br><span class="line">4 Disassociated due to inactivity</span><br><span class="line">5 Disassociated because AP is unable to handle all currently associated STAs</span><br><span class="line">6 Class 2 frame received from nonauthenticated STA</span><br><span class="line">7 Class 3 frame received from nonassociated STA</span><br><span class="line">8 Disassociated because sending STA is leaving (or has left) BSS</span><br><span class="line">9 STA requesting (re)association is not authenticated with responding STA</span><br><span class="line">10 Disassociated because the information in the Power Capability element is unacceptable</span><br><span class="line">11 Disassociated because the information in the Supported Channels element is unacceptable</span><br><span class="line">12 Reserved</span><br><span class="line">13 Invalid information element.</span><br><span class="line">14 Message integrity code (MIC) failure</span><br><span class="line">15 4-Way Handshake timeout</span><br><span class="line">16 Group Key Handshake timeout</span><br><span class="line">17 Information element in 4-Way Handshake different from (Re)Association Request/Probe Response/Beacon frame</span><br><span class="line">18 Invalid group cipher or Association denied due to requesting STA not supporting all of the data rates in the BSSBasicRateSet parameter</span><br><span class="line">19 Invalid pairwise cipher</span><br><span class="line">20 Invalid AKMP</span><br><span class="line">21 Unsupported RSN information element version</span><br><span class="line">22 Invalid RSN information element capabilities</span><br><span class="line">23 IEEE 802.1X authentication failed</span><br><span class="line">24 Cipher suite rejected because of the security policy</span><br><span class="line">25-31 Reserved</span><br><span class="line">32 Disassociated for unspecified, QoS-related reason</span><br><span class="line">33 Disassociated because QoS AP lacks sufficient bandwidth for this QoS STA</span><br><span class="line">34 Disassociated because excessive number of frames need to be acknowledged, but are not acknowledged due to AP transmissions and/or poor channel conditions</span><br><span class="line">35 Disassociated because STA is transmitting outside the limits of its TXOPs</span><br><span class="line">36 Requested from peer STA as the STA is leaving the BSS (or resetting)</span><br><span class="line">37 Requested from peer STA as it does not want to use the mechanism</span><br><span class="line">38 Requested from peer STA as the STA received frames using the mechanism for which a setup is required</span><br><span class="line">39 Requested from peer STA due to timeout</span><br><span class="line">45 Peer STA does not support the requested cipher suite</span><br><span class="line">45-65 Reserved</span><br><span class="line">535 Reserved</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/29/token%E4%B8%8Esession%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/myicon.jpg">
      <meta itemprop="name" content="LinWenXin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of WenXinLin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/29/token%E4%B8%8Esession%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">token与session的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-29 20:16:24" itemprop="dateCreated datePublished" datetime="2024-07-29T20:16:24+08:00">2024-07-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p><strong>session机制，原理</strong></p>
<p>session是服务端存储的一个对象，主要用来存储所有访问过该服务端的客户端的用户信息，从而实现保持用户会话状态。但是服务器重启时，内存会被销毁，存储的用户信息也就消失了。不同的用户访问服务端的时候会在session对象中存储键值对：”键”用来存储开启这个用户信息的”钥匙”，在登录成功后，”钥匙”通过cookie返回给客户端，客户端存储为sessionId记录在cookie中。当客户端再次访问时，会默认携带cookie中的sessionId来实现会话机制。</p>
</li>
</ol>
<p><img src="/images/blog_images/token%E4%B8%8Esession%E7%9A%84%E5%8C%BA%E5%88%AB/1722254837.png" alt="session"></p>
<pre><code>#session是基于cookie的：

1.  cookie的数据4k左右

2.  cookie存储数据的格式：字符串key=value

3.  cookie存储有效期：可以自行通过expires进行具体的日期设置，如果没设置，默认是关闭浏览器时失效。

4.  cookie有效范围：当前域名下有效。所以session这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上（前后端项目协议、域名、端口号都一致，即在一个项目下）

#session持久化：用于解决重启服务器后session就消失的问题。在数据库中存储session，而不是存储在内存中。

#当客户端存储的cookie失效后，服务端的session不会立即销毁，会有一个延时，服务端会定期清理无效session，避免无效数据占用存储空间。
</code></pre>
<ol start="2">
<li><p><strong>token机制，原理</strong></p>
<p>适用于项目级的前后端分离（前后端代码运行在不同的服务器下）</p>
</li>
</ol>
<p><img src="/images/blog_images/token%E4%B8%8Esession%E7%9A%84%E5%8C%BA%E5%88%AB/1722254856.png" alt="token"></p>
<pre><code>请求登录时，token和sessionId原理相同，是对key和key对应的用户信息进行加密后的加密字符，登录成功后，会在响应主体中将&#123;token：\&#39;字符串\&#39;&#125;返回给客户端。客户端通过cookie、sessionStorage、localStorage都可以进行存储。再次请求时不会默认携带，需要在请求拦截器位置给请求头中添加认证字段Authorization携带token信息，服务器端就可以通过token信息查找用户登录状态。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/20/WIFI6_mib%E9%A1%B9%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/myicon.jpg">
      <meta itemprop="name" content="LinWenXin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of WenXinLin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/20/WIFI6_mib%E9%A1%B9%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">WIFI6_mib项代码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-20 18:29:35" itemprop="dateCreated datePublished" datetime="2023-11-20T18:29:35+08:00">2023-11-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="一、项目背景"><a href="#一、项目背景" class="headerlink" title="一、项目背景"></a>一、项目背景</h4><p>在调试<code>wolink-cloud</code>时，遇见了两次<code>mib_get</code>引起的数组越界导致错误的问题，因此这次主要阅读 WIFI6 项目中 mib 相关的代码，以多域名 <code>LAN_DHCP_MULTI_DOMAIN</code> mib 配置项为例子，看看 mib 配置项是怎么工作的，包括如何定义、接口和串口获取和设置。</p>
<h4 id="二、主要文件"><a href="#二、主要文件" class="headerlink" title="二、主要文件"></a>二、主要文件</h4><p><code>mibtbl.c</code>、<code>mibtbl.h</code>、<code>mib.h</code>、<code>mib.c</code>、<code>msgparser.c</code>、<code>flash.c</code>。</p>
<h4 id="三、定义"><a href="#三、定义" class="headerlink" title="三、定义"></a>三、定义</h4><h5 id="mib-table"><a href="#mib-table" class="headerlink" title="mib_table"></a>mib_table</h5><p>在<code>mibtbl.c</code>中定义了一个全局的结构体数组<code>mib_table</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Global variable definitions */</span></span><br><span class="line">mib_table_entry_T mib_table[]=&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_USER_XDSL_SLAVE</span></span><br><span class="line">MIB_TBL_ENTRY(MIB_WAN_MODE, CURRENT_SETTING, <span class="string">&quot;WAN_MODE&quot;</span>, INTEGER_T, _OFFSET(wanmode), _SIZE(wanmode), <span class="string">&quot;15&quot;</span>),  <span class="comment">// Magician: Enable all wan mode by default.</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">MIB_TBL_ENTRY(MIB_WAN_MODE, CURRENT_SETTING, <span class="string">&quot;WAN_MODE&quot;</span>, INTEGER_T, _OFFSET(wanmode), _SIZE(wanmode), <span class="string">&quot;7&quot;</span>),  <span class="comment">// Magician: Enable all wan mode by default.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line">MIB_TBL_ENTRY(MIB_ADSL_LAN_DHCP_MULTI_DOMAIN,	CURRENT_SETTING,	<span class="string">&quot;LAN_DHCP_MULTI_DOMAIN&quot;</span>,	STRING_T,	_OFFSET(lan_dhcp_multi_domain), 	_SIZE(lan_dhcp_multi_domain),	<span class="string">&quot;wifi.cmcc,cmcc.wifi&quot;</span>),</span><br><span class="line">...</span><br><span class="line">MIB_TBL_ENTRY(MIB_MAC_FILTER_ENABLE, CURRENT_SETTING, <span class="string">&quot;MAC_FILTER_ENABLE&quot;</span>, BYTE_T, _OFFSET(mac_filter_enable), _SIZE(mac_filter_enable), <span class="string">&quot;0&quot;</span>),</span><br><span class="line">&#123;<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该结构体数组定义包括了一条条的<code>MIB_TBL_ENTRY</code>语句。</p>
<h6 id="MIB-TBL-ENTRY"><a href="#MIB-TBL-ENTRY" class="headerlink" title="MIB_TBL_ENTRY"></a>MIB_TBL_ENTRY</h6><p><code>MIB_TBL_ENTRY</code>是一个宏定义，定义在<code>mibtbl.h</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> INCLUDE_DEFAULT_VALUE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIB_TBL_ENTRY(ID, CLASS, NAME, TYPE, OFFSET, SIZE, DEFAULT) &#123;ID, CLASS, NAME, TYPE, OFFSET, SIZE, DEFAULT&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIB_TBL_ENTRY(ID, CLASS, NAME, TYPE, OFFSET, SIZE, DEFAULT) &#123;ID, CLASS, NAME, TYPE, OFFSET, SIZE &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>宏展开之后就是一个数组元素的初始化，数组元素的类型为自定义的结构体类型<code>mib_table_entry_T</code>。</p>
<h6 id="mib-table-entry-T"><a href="#mib-table-entry-T" class="headerlink" title="mib_table_entry_T"></a>mib_table_entry_T</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">mib_table_entry</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	CONFIG_DATA_T mib_type;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">48</span>];</span><br><span class="line">	TYPE_T type;</span><br><span class="line">	<span class="type">int</span> offset;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> INCLUDE_DEFAULT_VALUE</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *defaultValue;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; mib_table_entry_T;</span><br></pre></td></tr></table></figure>

<p>多域名mib项宏展开之后就是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;MIB_ADSL_LAN_DHCP_MULTI_DOMAIN, CURRENT_SETTING, <span class="string">&quot;LAN_DHCP_MULTI_DOMAIN&quot;</span>, STRING_T, _OFFSET(lan_dhcp_multi_domain), _SIZE(lan_dhcp_multi_domain), <span class="string">&quot;wifi.cmcc,cmcc.wifi&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>MIB_ADSL_LAN_DHCP_MULTI_DOMAIN</code>是一个枚举值，枚举定义在<code>mib.h</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * ADSL Router MIB ID</span><br><span class="line"> */</span><br><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">	CS_ENTRY_ID = 0,</span><br><span class="line">	MIB_ADSL_LAN_IP,</span><br><span class="line">	...</span><br><span class="line">	/* apply for support multi domain, ex: &quot;cmcc.wifi,wifi.cmcc&quot; */</span><br><span class="line">	MIB_ADSL_LAN_DHCP_MULTI_DOMAIN,</span><br><span class="line">	/* mac filter enable */</span><br><span class="line">	MIB_MAC_FILTER_ENABLE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再看<code>_OFFSET</code>以及<code>_SIZE</code>的宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIELD_OFFSET(type, field)	((unsigned long)(long *)&amp;(((type *)0)-&gt;field))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OFFSET(field)			((intptr_t)FIELD_OFFSET(MIB_T,field))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SIZE(field)			sizeof(((MIB_T *)0)-&gt;field)</span></span><br></pre></td></tr></table></figure>

<p>可以看到这两个宏是用来获取一个 field 在一个结构体中的偏移量以及占用的字节数。因此可以推断<code>lan_dhcp_multi_domain</code>是一个结构体中的成员变量，该结构体为<code>MIB_T</code>。</p>
<h6 id="MIB-T"><a href="#MIB-T" class="headerlink" title="MIB_T"></a>MIB_T</h6><p>果然，在<code>mib.h</code>中可以找到结构体定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * MIB struct</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">config_setting</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RTK_DNS_TRAP</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> lan_dhcp_multi_domain[MAX_DOMAIN_NUM * MAX_DOMAIN_NAME_LEN + MAX_DOMAIN_NUM]; <span class="comment">//aplly for cmcc.wifi and wifi.cmcc</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	...</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> mac_filter_enable;</span><br><span class="line">&#125; __PACK__ MIB_T, *MIB_Tp;</span><br></pre></td></tr></table></figure>

<p>这个就是整个 mib 配置项了，实际存放 mib 值的地方。</p>
<h4 id="四、获取"><a href="#四、获取" class="headerlink" title="四、获取"></a>四、获取</h4><p>在开发中，经常需要获取 mib 项的值，一般是通过<code>mib_get</code>获取，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mib_get(MIB_ADSL_LAN_DHCP_MULTI_DOMAIN, (<span class="type">void</span> *)strDevName);</span><br></pre></td></tr></table></figure>

<p>会去读取mib中<code>MIB_ADSL_LAN_DHCP_MULTI_DOMAIN</code>对应的 mib 项中的值，并写到<code>strDevName</code>指向的内存中。</p>
<h5 id="mib-get"><a href="#mib-get" class="headerlink" title="mib_get()"></a>mib_get()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mib_get</span><span class="params">(<span class="type">int</span> id, <span class="type">void</span> *value)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> mib_get_s(id, value, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mib_get()</code>是对<code>mib_get_s()</code>的封装。</p>
<h5 id="mib-get-s"><a href="#mib-get-s" class="headerlink" title="mib_get_s()"></a>mib_get_s()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mib_get_s</span><span class="params">(<span class="type">int</span> id, <span class="type">void</span> *value, <span class="type">int</span> value_len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mymsgbuf</span> <span class="title">qbuf</span>;</span></span><br><span class="line">	MSG_T *mymsg;</span><br><span class="line">	mib_table_entry_T info;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WLAN_SUPPORT</span></span><br><span class="line">	id = wlan_mib_id_reorder(id);</span><br><span class="line">	<span class="keyword">if</span> (id == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s: Invalid wlan_idx: %d\n&quot;</span>, __FUNCTION__, wlan_idx);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!mib_info_id(id, &amp;info))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>((<span class="type">void</span> *)&amp;qbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mymsgbuf));</span><br><span class="line">	mymsg = &amp;qbuf.msg;</span><br><span class="line">	mymsg-&gt;cmd = CMD_MIB_GET;</span><br><span class="line">	mymsg-&gt;arg1 = id;</span><br><span class="line"></span><br><span class="line">	sendcmd(&amp;qbuf);</span><br><span class="line">	<span class="keyword">if</span> (qbuf.request == MSG_SUCC) &#123;</span><br><span class="line">		<span class="keyword">if</span> (value_len &gt; <span class="number">0</span> &amp;&amp;  value_len &lt; info.size) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\033[31;1;4mWARN: Program(%s) mib_get() ID (%d,%s) size=%d but value buffer size=%d\033[0m\n&quot;</span>, __progname, id, info.name, info.size, value_len);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memcpy</span>(value, mymsg-&gt;mtext, info.size);</span><br><span class="line">		ret = <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s: Get request failed! (id=%d)\n&quot;</span>, __func__, id);</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先在<code>wlan_mib_id_reorder</code>中会判断需要获取的 mib 项的 id 是不是无线多接口的id：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	Reorder mib id for wlan mib in case of multiple wlan interfaces.</span><br><span class="line"> *	Return value: reordered wlan mib id based on wlan_idx, -1 on error.</span><br><span class="line"> */</span><br><span class="line">static int wlan_mib_id_reorder(int id)</span><br><span class="line">&#123;</span><br><span class="line">	int mib_id=id;</span><br><span class="line">	</span><br><span class="line">	if (id &gt; DUAL_WLAN_START_ID &amp;&amp; id &lt; DUAL_WLAN_END_ID) &#123;</span><br><span class="line">		mib_id = -1;</span><br><span class="line">		if (isValid_wlan_idx(wlan_idx))</span><br><span class="line">			mib_id = id + wlan_idx;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return mib_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DUAL_WLAN_START_ID</code>和<code>DUAL_WLAN_END_ID</code>是作为无线多接口 id 的开始和结束标志，定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	WLAN_CS_ENTRY_ID = <span class="number">1000</span>,</span><br><span class="line">    DUAL_WLAN_START_ID = WLAN_CS_ENTRY_ID,</span><br><span class="line"></span><br><span class="line"><span class="comment">//================== start of dual wlan interface definition=================</span></span><br><span class="line">    MIB_MAPPING(SSID),</span><br><span class="line">    MIB_MAPPING(CHAN_NUM),</span><br><span class="line">    MIB_MAPPING(OFDMA_ENABLED),</span><br><span class="line"></span><br><span class="line">    DUAL_WLAN_END_ID,</span><br><span class="line"></span><br><span class="line"><span class="comment">//==================end of dual wlan interface definition=================</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而<code>MIB_MAPPING</code>宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIB_MAPPING(name) \</span></span><br><span class="line"><span class="meta">    MIB_WLAN_##name, \</span></span><br><span class="line"><span class="meta">    MIB_WLAN1_##name, \</span></span><br><span class="line"><span class="meta">    MIB_WLAN2_##name</span></span><br></pre></td></tr></table></figure>

<p>也就是一个<code>MIB_MAPPING</code>就定义了三个id，我们在获取2.4G或者5G的配置项时，需要设置全局变量<code>wlan_idx</code>为0或者1，作用就在这里：<code>mib_id = id + wlan_idx;</code>。</p>
<p>然后通过<code>mib_info_id</code>获取需要的 mib 项的信息，即获取<code>mib_table</code>中的一个元素。获取过程最后是通过调用了<code>cfg_mib_info_id</code>来获取的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cfg_mib_info_id</span><span class="params">(<span class="keyword">struct</span> mymsgbuf *qbuf)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="type">void</span> *)qbuf-&gt;msg.mtext, (<span class="type">void</span> *)&amp;mib_table[k], <span class="keyword">sizeof</span>(mib_table_entry_T));</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>mib_info_id</code>中将获取到的 mib 项信息拷贝出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mib_info_id</span><span class="params">(<span class="type">int</span> id, mib_table_entry_T * info)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">memcpy</span>(info, mymsg-&gt;mtext, <span class="keyword">sizeof</span>(mib_table_entry_T));</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再去获取 mib 项中存放的值，这一过程最终会通过id调用<code>_mib_get</code>进行字符串或者内存拷贝获取：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _mib_get(<span class="type">int</span> id, <span class="type">void</span> *value) <span class="comment">/* get mib value */</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">strcpy</span>((<span class="type">char</span> *)value, (<span class="type">const</span> <span class="type">char</span> *)(pMibTbl + mib_table[i].offset));</span><br><span class="line">	...<span class="comment">//or</span></span><br><span class="line">	<span class="built_in">memcpy</span>(value, pMibTbl + mib_table[i].offset, mib_table[i].size);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>pMibTbl</code>指向前面定义的<code>config_setting</code>结构体，即<code>MIB_T</code>（有可能是其他类似的结构体，通过mib项的mib_type定向，加上需要获取的 mib 项在这个结构体中的偏移量以及占用字节大小，可以将 mib 值拷贝出来，最后再一次通过<code>memcpy</code>拷贝到<code>mib_get</code>的第二个实参中。</p>
<p>注意，这里可能会出现内存溢出的问题！如何解决？<strong>确保用来存放获取值的变量大小不小于mib配置项定义的大小</strong>。</p>
<h4 id="五、设置"><a href="#五、设置" class="headerlink" title="五、设置"></a>五、设置</h4><p>如果需要修改mib项的值，需要通过<code>mib_set</code>设置。</p>
<h5 id="mib-set"><a href="#mib-set" class="headerlink" title="mib_set()"></a>mib_set()</h5><p>函数定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mib_set</span><span class="params">(<span class="type">int</span> id, <span class="type">void</span> *value)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mymsgbuf</span> <span class="title">qbuf</span>;</span></span><br><span class="line">	MSG_T *mymsg;</span><br><span class="line">	mib_table_entry_T info;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WLAN_SUPPORT</span></span><br><span class="line">	id = wlan_mib_id_reorder(id);</span><br><span class="line">	<span class="keyword">if</span> (id == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s: Invalid wlan_idx: %d\n&quot;</span>, __FUNCTION__, wlan_idx);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!mib_info_id(id, &amp;info))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	mymsg = &amp;qbuf.msg;</span><br><span class="line">	mymsg-&gt;cmd = CMD_MIB_SET;</span><br><span class="line">	mymsg-&gt;arg1 = id;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_USER_CWMP_TR069</span></span><br><span class="line">	mymsg-&gt;arg2 = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">memcpy</span>(mymsg-&gt;mtext, value, info.size);</span><br><span class="line"></span><br><span class="line">	sendcmd(&amp;qbuf);</span><br><span class="line">	<span class="keyword">if</span> (qbuf.request != MSG_SUCC) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s: Set request failed! (id=%d)\n&quot;</span>, __func__, id);</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_USER_DBUS_PROXY</span></span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		send_notify_msg_dbusproxy(id, e_dbus_signal_mib_set, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_E8B) &amp;&amp; defined(CONFIG_USER_LANNETINFO)</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">rtk_e8_mib_set_signal_to_lannetinfo</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">	rtk_e8_mib_set_signal_to_lannetinfo(ret, id);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面的步骤跟<code>mib_get_s()</code>一样，即判断是否是无线的mib以及获取mib项信息。</p>
<p>不一样的是将<code>cmd</code>类型设置为<code>CMD_MIB_SET</code>，将需要设置的值<code>memcpy</code>到<code>mtext</code>中，通过<code>sendcmd</code>去设置。这个过程和获取一样，需要和<code>configd</code>进程通信。</p>
<p>最终会根据<code>CMD_MIB_SET</code>去调用<code>cfg_mib_set</code>。</p>
<h5 id="cfg-mib-set"><a href="#cfg-mib-set" class="headerlink" title="cfg_mib_set()"></a>cfg_mib_set()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cfg_mib_set</span><span class="params">(<span class="keyword">struct</span> mymsgbuf *qbuf)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (_mib_set(qbuf-&gt;msg.arg1, (<span class="type">void</span> *)qbuf-&gt;msg.mtext) != <span class="number">0</span>) &#123;</span><br><span class="line">		qbuf-&gt;request = MSG_SUCC;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终会调用<code>_mib_set</code>进行设置。</p>
<h5 id="mib-set-1"><a href="#mib-set-1" class="headerlink" title="_mib_set()"></a>_mib_set()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _mib_set(<span class="type">int</span> id, <span class="type">void</span> *value) <span class="comment">/* set mib value */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> * pMibTbl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// search current setting mib table</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; mib_table[i].id; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( mib_table[i].id == id )</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			TRACE(&quot;mib_set %s\n&quot;,mib_table[i].name);</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((mib_table[i].mib_type != CURRENT_SETTING) &amp;&amp;</span><br><span class="line">		(mib_table[i].mib_type != HW_SETTING) &amp;&amp;</span><br><span class="line">		(mib_table[i].mib_type != RUNNING_SETTING))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pMibTbl = __mib_get_mib_tbl(mib_table[i].mib_type);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (mib_table[i].type) &#123;</span><br><span class="line">	<span class="keyword">case</span> BYTE_T:</span><br><span class="line">	<span class="keyword">case</span> WORD_T:</span><br><span class="line">	<span class="keyword">case</span> DWORD_T:</span><br><span class="line">	<span class="keyword">case</span> INTEGER_T:</span><br><span class="line">	<span class="keyword">case</span> BYTE5_T:</span><br><span class="line">	<span class="keyword">case</span> BYTE6_T:</span><br><span class="line">	<span class="keyword">case</span> BYTE13_T:</span><br><span class="line">	<span class="keyword">case</span> BYTE_ARRAY_T:</span><br><span class="line">	<span class="keyword">case</span> IA_T:</span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> CONFIG_IPV6</span></span><br><span class="line">	<span class="keyword">case</span> IA6_T:</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="built_in">memcpy</span>(pMibTbl + mib_table[i].offset, value, mib_table[i].size);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> INT_ARRAY_T:</span><br><span class="line">		<span class="built_in">memcpy</span>(pMibTbl + mib_table[i].offset, value, mib_table[i].size);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> ENCRYPT_STRING_T:</span><br><span class="line">	<span class="keyword">case</span> STRING_T:</span><br><span class="line">		<span class="keyword">if</span> ( <span class="built_in">strlen</span>(value)+<span class="number">1</span> &gt; mib_table[i].size )</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">strcpy</span>(pMibTbl + mib_table[i].offset, value);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过程和<code>_mib_get</code>差不多，也是先通过id去获取mib信息，然后通过size和offset去<code>mib_table</code>中去设置mib值，设置方法也是<code>memcpy</code>或者<code>strcpy</code>。</p>
<h4 id="六、串口命令"><a href="#六、串口命令" class="headerlink" title="六、串口命令"></a>六、串口命令</h4><p>在开发或测试中经常需要通过串口输入命令去获取或设置 mib 配置项。最常见的就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flash all | grep ...</span><br><span class="line">flash get &lt;MIB_NAME&gt;</span><br><span class="line">flash set &lt;MIB_NAME&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>

<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Usage: flash cmd</span><br><span class="line">cmd:</span><br><span class="line">  info 				show flash offset information.</span><br><span class="line">  loop 				enter a infinite loop.</span><br><span class="line">  get_def &lt;MIB-NAME&gt; [...] 		get the default value of specific mib from flash memory.</span><br><span class="line">    Example:</span><br><span class="line">      get_def NTP_ENABLED 		get the default value of specific mib table entry from flash memory.</span><br><span class="line">      get_def ATM_VC_TBL 		get the default value of specific mib chain from flash memory.</span><br><span class="line">      get_def ATM_VC_TBL.NUM 	get the default number of specific mib chain from flash memory.</span><br><span class="line">      get_def ATM_VC_TBL.0.ifIndex 	get the default value of specific member of the mib chain record from flash memory.</span><br><span class="line">  all_def [cs|hs] 			dump all mib default value from flash memory.</span><br><span class="line">  get &lt;MIB-NAME&gt; [...] 		get the specific mib from flash memory.</span><br><span class="line">    Example:</span><br><span class="line">      get NTP_ENABLED 		get the specific mib table entry from flash memory.</span><br><span class="line">      get ATM_VC_TBL 		get all the specific mib chain records from flash memory.</span><br><span class="line">      get ATM_VC_TBL.NUM 	get the specific mib chain record size from flash memory.</span><br><span class="line">      get ATM_VC_TBL.0.ifIndex 	get the specific member of the mib chain record from flash memory.</span><br><span class="line">  set &lt;MIB-NAME MIB-VALUE&gt; [...]set the specific mib into flash memory.</span><br><span class="line">    Example:</span><br><span class="line">      set NTP_ENABLED 0 	set the specific mib table entry into flash memory.</span><br><span class="line">      set ATM_VC_TBL.1.vpi 8 	set the specific member of the mib chain recrod into flash memory.</span><br><span class="line">  add &lt;MIB-CHAIN-NAME&gt; [...] 	add mib chain record(s) into flash memory.</span><br><span class="line">    Example:</span><br><span class="line">      add ATM_VC_TBL 		add a mib chain record into flash memory.</span><br><span class="line">      add ATM_VC_TBL.2 		add mib chain record(s) into flash memory.</span><br><span class="line">  del &lt;MIB-CHAIN-NAME&gt; [...] 	delete mib chain record(s) into flash memory.</span><br><span class="line">    Example:</span><br><span class="line">      del ATM_VC_TBL 		delete the last mib chain record into flash memory.</span><br><span class="line">      del ATM_VC_TBL.2 		delete the specific mib chain record into flash memory.</span><br><span class="line">  all [cs|hs] 			dump all flash parameters.</span><br><span class="line">  list [cs|hs|all] [sorted] 	list mib parameters(sorted).</span><br><span class="line">  default &lt;cs/hs&gt; 		write program default value to flash.</span><br><span class="line">  clear 			clear flash setting.</span><br><span class="line">  get_wlband_num 			get wlan band number.</span><br><span class="line">  r &lt;OFFSET&gt; 			read flash from &lt;OFFSET&gt;.</span><br><span class="line">  w &lt;OFFSET&gt; &lt;VALUE&gt; 		write flash to &lt;OFFSET&gt;.</span><br><span class="line">  erase &lt;OFFSET&gt; 		erase flash from &lt;OFFSET&gt;.</span><br><span class="line">  set_rt &lt;cs&gt; [ENTRY-NAME] [MIB-NAME] [MIB-VALUE] [ENTRY-INDEX]   : set a specific default mib value on dut runtime.</span><br><span class="line">    [ENTRY_NAME]: If you want to set the value of a single MIB_TABLE, please keep it as &#x27;MIB_TABLE&#x27;.</span><br><span class="line">                  If you want to set the members of Chain, please enter the corresponding Chain Name.</span><br><span class="line">    [ENTRY_INDEX]: If there is no such value, then do not write. When setting for the first time, add the index value from 0.</span><br><span class="line">    Example:</span><br><span class="line">      a)set_rt cs MIB_TABLE MIB_LAN_IP_ADDR 192.168.1.1 		set lan Ip addr to 192.168.1.1.</span><br><span class="line">      b)set_rt cs WLAN_MBSSIB_TBL ssid ChinaNet-wlan-5G 0 		set wlan0 root ssid to ChinaNet-wlan-5G.</span><br><span class="line">  xmlchk &lt;XMLFILENAME&gt; 		check if the xml config file is valid.</span><br><span class="line">  swap wlan &lt;cs/hs&gt; 		swap wlan mib.</span><br></pre></td></tr></table></figure>

<p>解析命令并生效的代码在<code>user/boa/src/LINUX/flash.c</code>中。</p>
<h5 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; cmd_table[i].cmd_name; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(cmd_table[i].cmd_name, argv[<span class="number">1</span>]) == <span class="number">0</span>) &#123;</span><br><span class="line">			ret = cmd_table[i].cmd_func(argc - <span class="number">1</span>, argv + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main</code>函数中会去遍历<code>cmd_table</code>，根据 flash 命令的第一个参数去执行不同的函数进行处理。可以知道最常用的 <code>flash get</code>命令会去调用<code>get_func</code>，<code>flash set</code>命令会调用<code>set_func</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> *cmd_name;</span><br><span class="line">	<span class="type">int</span> (*cmd_func)(<span class="type">int</span> argc, <span class="type">char</span> *argv[]);</span><br><span class="line">&#125; cmd_table[] = &#123;</span><br><span class="line">	&#123; <span class="string">&quot;info&quot;</span>, info_func &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;loop&quot;</span>, loop_func &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;get_def&quot;</span>, get_func &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;all_def&quot;</span>, all_func &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;get&quot;</span>, get_func &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;set&quot;</span>, set_func &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;add&quot;</span>, add_del_func &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;del&quot;</span>, add_del_func &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;all&quot;</span>, all_func &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;list&quot;</span>, list_func &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_USER_XMLCONFIG) &amp;&amp; !defined(CONFIG_USER_CONF_ON_XMLFILE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CAN_RW_FILE</span></span><br><span class="line">	&#123; <span class="string">&quot;rds&quot;</span>, rs_func &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;rcs&quot;</span>, rs_func &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;rhs&quot;</span>, rs_func &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;wds&quot;</span>, ws_func &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;wcs&quot;</span>, ws_func &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;whs&quot;</span>, ws_func &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#123; <span class="string">&quot;check&quot;</span>, check_func &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;dump&quot;</span>, dump_func &#125;,</span><br><span class="line">	<span class="comment">//&#123; &quot;reset&quot;, reset_func &#125;,</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#123; <span class="string">&quot;default&quot;</span>, default_func &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;clear&quot;</span>, clear_func &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;get_wlband_num&quot;</span>, get_wlband_func &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> VOIP_SUPPORT</span></span><br><span class="line">	&#123; <span class="string">&quot;voip&quot;</span>, voip_func &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_11N_UDP_SERVER	<span class="comment">//cathy test</span></span></span><br><span class="line">	&#123; <span class="string">&quot;gethw&quot;</span>, gethw_func &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;sethw&quot;</span>, sethw_func &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#123; <span class="string">&quot;w&quot;</span>, w_func &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;r&quot;</span>, r_func &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;erase&quot;</span>, erase_func &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_USER_XMLCONFIG) &amp;&amp; defined(CONFIG_USER_CONF_ON_XMLFILE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (CONFIG_DEFAULT_CONF_ON_RT_XMLFILE)</span></span><br><span class="line">	&#123; <span class="string">&quot;set_rt&quot;</span>, set_rt_func &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#123; <span class="string">&quot;xmlchk&quot;</span>, xmlchk_func &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(SWAP_WLAN_MIB) </span></span><br><span class="line">	&#123;<span class="string">&quot;swap&quot;</span>, swap_wlan_func&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#123; <span class="number">0</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里我们主要分析一下 get 和 set 命令。</p>
<h5 id="get-func"><a href="#get-func" class="headerlink" title="get_func"></a>get_func</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_func</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> argNum, ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> mib[<span class="number">100</span>];</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">2048</span>];</span><br><span class="line">	CONFIG_MIB_T flag;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		showHelp();</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (argNum = <span class="number">1</span>; argNum &lt; argc; argNum++) &#123;</span><br><span class="line">		flag = mib_name_resolve(argv[argNum], mib);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_11N_UDP_SERVER</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">strncmp</span>(mib, <span class="string">&quot;HW_WLAN&quot;</span>, <span class="number">7</span>))</span><br><span class="line">			udp_server_cmd = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span> (flag == CONFIG_MIB_CHAIN &amp;&amp; (ret = mib_chain_get_by_name(mib, buffer)) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ret == error)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;fail: %s\n&quot;</span>, buffer);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag == CONFIG_MIB_TABLE &amp;&amp; (ret = mib_table_get_by_name(mib, buffer)) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s=%s\n&quot;</span>, mib, buffer);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(mib, <span class="string">&quot;HW_PROVINCE_FEATURE_VER&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!provinceFeatureExist(buffer)) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;\033[33mWarning: PROVINCE_FEATURE_VER is not exist!\033[0m\n&quot;</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!areaMatchFeature(buffer)) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;\033[33mWarning: PROVINCE_FEATURE_VER and AREA not match, feature will not open!\033[0m\n&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ret = error;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_11N_UDP_SERVER</span></span><br><span class="line">		udp_server_cmd = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先通过执行命令传递进来的 MIB_NAME，获取映射的 MIB_NAME，以及一个 flag 用来区分需要获取的是一个 mib 项还是一个 chain；然后通过该 MIB_NAME 和 flag 获取 mib 项的值。</p>
<p>如果是获取多域名，会调用<code>mib_table_get_by_name</code>，这里只写出了重要的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mib_table_get_by_name</span><span class="params">(<span class="type">char</span> *name, <span class="type">char</span> *buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, id = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> mibvalue[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; mib_table[i].id; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(mib_table[i].name, name)) &#123;</span><br><span class="line">			id = mib_table[i].id;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fails */</span></span><br><span class="line">	<span class="keyword">if</span> (_mib_get(id, mibvalue) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	mib_to_string_ex(buffer, mibvalue, mib_table[i].type, mib_table[i].size, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先通过 MIB_NAME 获取 mib id，然后通过 mib id 获取 mib 值（调用的也是<code>_mib_get</code>，最后再拷贝到 buff 中。这两次拷贝都是用的 <code>strcpy</code>，因此只要 mib 值字符串不超过 1024 字节大小，通过 <code>flash get</code>出来的值都不会有问题。</p>
<h5 id="set-func"><a href="#set-func" class="headerlink" title="set_func"></a>set_func</h5><p><code>set_func</code>函数跟<code>get_func</code>差不多，这里定义省略了不重要的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">set_func</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> argNum, index, ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">2048</span>];</span><br><span class="line">    ...</span><br><span class="line">			argNum += mib_table_value_resolve(index, argc - argNum, &amp;argv[argNum], buffer);</span><br><span class="line">			<span class="keyword">if</span> ((tmpType = mib_table_set_by_index(index, buffer)) != <span class="number">0</span>) &#123;</span><br><span class="line">				cdType |= tmpType;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;set %s=%s\n&quot;</span>, mib, buffer);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;set %s=%s fail!\n&quot;</span>, mib, buffer);</span><br><span class="line">				ret = error;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag == CONFIG_MIB_CHAIN) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((tmpType = mib_chain_set_by_name(mib, argv[argNum + <span class="number">1</span>])) != <span class="number">0</span>) &#123;</span><br><span class="line">				cdType |= tmpType;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;set %s=%s\n&quot;</span>, argv[argNum], argv[argNum + <span class="number">1</span>]);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;set %s=%s fail!\n&quot;</span>, argv[argNum], argv[argNum + <span class="number">1</span>]);</span><br><span class="line">				ret = error;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			argNum += <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((cdType &amp; CURRENT_SETTING) &amp;&amp; _mib_update(CURRENT_SETTING) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;CS Flash error! \n&quot;</span>);</span><br><span class="line">		ret = error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((cdType &amp; HW_SETTING) &amp;&amp; _mib_update(HW_SETTING) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;HS Flash error! \n&quot;</span>);</span><br><span class="line">		ret = error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用<code>mib_table_value_resolve</code>将 flash 命令中需要设置的参数值拷贝到 buffer 中，这里面用的是 strcpy 进行拷贝。</p>
<p>然后调用<code>mib_table_set_by_index</code>将 buffer 中的值设置进 mib 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set MIB Value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> CONFIG_DATA_T <span class="title function_">mib_table_set_by_index</span><span class="params">(<span class="type">int</span> index, <span class="type">char</span> *buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> mibvalue[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	CONFIG_DATA_T cdtype;</span><br><span class="line"></span><br><span class="line">	id = mib_table[index].id;</span><br><span class="line">	cdtype = mib_table[index].mib_type;</span><br><span class="line"></span><br><span class="line">	string_to_mib(mibvalue, buffer, mib_table[index].type, mib_table[index].size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (_mib_set(id, mibvalue))</span><br><span class="line">		<span class="keyword">return</span> cdtype;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>string_to_mib</code>中对<code>STRING_T</code>类型的 mib 项，是通过<code>strncpy</code>进行拷贝，拷贝时<code>dest</code>的大小为1024字节，如果mib项的大小大于1024字节，会出现数组越界的问题。</p>
<p>最后再调用<code>_mib_set</code>将设置值写入 mib 项中，完成设置。</p>
<p>设置完成之后会调用<code>_mib_update</code>更新mib配置。</p>
<h4 id="七、配置文件"><a href="#七、配置文件" class="headerlink" title="七、配置文件"></a>七、配置文件</h4><p>我们通常有配置文件，里面会包含一些mib配置，那么配置文件有什么用呢？跟mib配置有什么关系呢？</p>
<p>首先看一下<code>/etc/config_default.xml</code>配置文件的内容格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Value Name=&quot;WLAN1_AGGREGATION&quot; Value=&quot;3&quot;/&gt;</span><br><span class="line">      &lt;chain chainName=&quot;ATM_VC_TBL&quot;&gt; &lt;!--index=0--&gt;</span><br><span class="line">              &lt;Value Name=&quot;AddrMode&quot; Value=&quot;1&quot;/&gt;</span><br><span class="line">              &lt;Value Name=&quot;Ipv6Dhcp&quot; Value=&quot;1&quot;/&gt;</span><br><span class="line">              &lt;Value Name=&quot;Ipv6DhcpRequest&quot; Value=&quot;2&quot;/&gt;</span><br><span class="line">              &lt;Value Name=&quot;enableIGMP&quot; Value=&quot;1&quot;/&gt;</span><br><span class="line">      &lt;/chain&gt;</span><br></pre></td></tr></table></figure>

<p>对于mib项的获取和设置，是通过发送消息队列给<code>configd</code>这个程序去进行的，而在<code>configd</code>这个程序的main函数开始的时候会调用<code>mib_init</code>进行mib的初始化，其实在flash程序中也会进行<code>mib_init</code>，初始化是必不可少的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mib_init</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">/* Initialize */</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (hs_valid == <span class="number">0</span> &amp;&amp;</span><br><span class="line">		mib_init_mib_with_program_default(HW_SETTING, FLASH_DEFAULT_TO_ALL, CONFIG_MIB_ALL)) &#123;</span><br><span class="line">		hs_valid = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\033[0;31m%s: Invalid HS config file, reset to default!\n\033[0m&quot;</span>, __FUNCTION__);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cs_valid == <span class="number">0</span> &amp;&amp;</span><br><span class="line">		mib_init_mib_with_program_default(CURRENT_SETTING, FLASH_DEFAULT_TO_ALL, CONFIG_MIB_ALL)) &#123;</span><br><span class="line">		cs_valid = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\033[0;31m%s: Invalid CS config file, reset to default!\n\033[0m&quot;</span>, __FUNCTION__);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mib_init</code>会调用<code>mib_init_mib_with_program_default</code>，接着看该函数的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mib_init_mib_with_program_default</span><span class="params">(CONFIG_DATA_T data_type, <span class="type">int</span> action, CONFIG_MIB_T range)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">if</span> (access(data_type == HW_SETTING ? CONF_ON_XMLFILE_DEFAULT_HS : CONF_ON_XMLFILE_DEFAULT, R_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (_load_xml_file(data_type == HW_SETTING ? CONF_ON_XMLFILE_DEFAULT_HS : CONF_ON_XMLFILE_DEFAULT, data_type, <span class="number">0</span>, range) == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[%s] Error: _load_xml_file %s fail !\n&quot;</span>, __FUNCTION__, data_type == HW_SETTING ? CONF_ON_XMLFILE_DEFAULT_HS : CONF_ON_XMLFILE_DEFAULT);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>CONF_ON_XMLFILE_DEFAULT</code>和<code>CONF_ON_XMLFILE_DEFAULT_HS</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> CONF_ON_XMLFILE_DEFAULT[] = <span class="string">&quot;/etc/config_default.xml&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> CONF_ON_XMLFILE_DEFAULT_HS[] = <span class="string">&quot;/etc/config_default_hs.xml&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这两个xml文件也就是我们的默认配置文件。在调用<code>access</code>确定此进程能对配置文件进行读操作之后，调用<code>_load_xml_file</code>。</p>
<p><code>_load_xml_file</code>函数实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _load_xml_file(<span class="type">const</span> <span class="type">char</span> *loadfile, CONFIG_DATA_T cnf_type, <span class="type">unsigned</span> <span class="type">char</span> flag, CONFIG_MIB_T action)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">/* 以读的方式打开配置文件 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(fp = fopen(loadfile, <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;User configuration file can not be opened: %s\n&quot;</span>, loadfile);</span><br><span class="line">		ret = error;</span><br><span class="line">		<span class="built_in">free</span>(head);</span><br><span class="line">		<span class="keyword">goto</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">    flock(fileno(fp), LOCK_SH);  <span class="comment">/* 对配置文件建立共享锁定 */</span></span><br><span class="line">    pstr = get_line(fp, LINE, <span class="keyword">sizeof</span>(LINE));  <span class="comment">/* 读取文件第一行数据，并去除行首行尾的空白符 */</span></span><br><span class="line">	<span class="keyword">if</span>(pstr==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		ret = error;</span><br><span class="line">		<span class="built_in">free</span>(head);</span><br><span class="line">		flock(fileno(fp), LOCK_UN);</span><br><span class="line">		<span class="keyword">goto</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">while</span> (!feof(fp)) &#123;</span><br><span class="line">		pstr = get_line(fp, LINE, <span class="keyword">sizeof</span>(LINE));	<span class="comment">//get one line from the file</span></span><br><span class="line">		<span class="keyword">if</span>(pstr != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strlen</span>(pstr) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(pstr, CONFIG_TRAILER)  <span class="comment">/* 文件读到了最后一行，退出 */</span></span><br><span class="line">				    || !<span class="built_in">strcmp</span>(pstr, CONFIG_TRAILER_HS)) &#123;</span><br><span class="line">				    isEnd=<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;	<span class="comment">// end of configuration</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">/* 把从配置文件中读取的每一行更新到mib中 */</span></span><br><span class="line">				<span class="keyword">if</span> (update_setting(fp, pstr, cnf_type, head, action) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;update setting fail!\n&quot;</span>);</span><br><span class="line">					ret = error;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终会调用<code>update_setting</code>，看此函数的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">update_setting</span><span class="params">(FILE *fp, <span class="type">char</span> *line, CONFIG_DATA_T cnf_type, chainNode_t * head, CONFIG_MIB_T action)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line, <span class="string">&quot;&lt;Value&quot;</span>, <span class="number">6</span>))&#123;</span><br><span class="line">		<span class="keyword">if</span>(action == CONFIG_MIB_ALL || action == CONFIG_MIB_TABLE)</span><br><span class="line">			ret = table_setting(line, cnf_type);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line, <span class="string">&quot;&lt;chain&quot;</span>, <span class="number">6</span>))&#123;</span><br><span class="line">		<span class="keyword">if</span>(action == CONFIG_MIB_ALL || action == CONFIG_MIB_CHAIN)</span><br><span class="line">			ret = chain_setting(fp, line, cnf_type, head);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">// ignore the whole chain</span></span><br><span class="line">			DEBUGP(<span class="string">&quot;skip %s\n&quot;</span>, line);</span><br><span class="line">			mib_chain_member_entry_T root_desc_fake;</span><br><span class="line">			skip_value_object(fp, &amp;root_desc_fake);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Unknown statement: %s\n&quot;</span>, line);</span><br><span class="line">		ret = error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据在配置文件中读取的每行字符串数据中的字眼来分别设置mib_table或者mib_chain。</p>
<p>看一下mib_table的设置，调用<code>table_setting</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">table_setting</span><span class="params">(<span class="type">char</span> *line, CONFIG_DATA_T cnf_type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> *pname, *pvalue;</span><br><span class="line">	<span class="type">char</span> *first, *last;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> mibvalue[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取mib的name</span></span><br><span class="line">	first = <span class="built_in">strchr</span>(line, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span>(first==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	pname = first+<span class="number">1</span>;</span><br><span class="line">	last = <span class="built_in">strchr</span>(pname, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span>(last==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	*last = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	DEBUGP(<span class="string">&quot;table name=%-25s&quot;</span>, pname);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; mib_table[i].id; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mib_table[i].mib_type != cnf_type)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">/* 在mib_table中通过name找到该项mib */</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(mib_table[i].name, pname))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mib_table[i].id == <span class="number">0</span>) &#123;</span><br><span class="line">		TRACE(STA_WARNING, <span class="string">&quot;%s: Invalid table entry name: %s\n&quot;</span>, __FUNCTION__, pname);</span><br><span class="line">		<span class="comment">//return error;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取mib的value</span></span><br><span class="line">	first = <span class="built_in">strchr</span>(last+<span class="number">1</span>, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span>(first==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	pvalue = first+<span class="number">1</span>;</span><br><span class="line">	last = <span class="built_in">strrchr</span>(pvalue, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span> (last == <span class="literal">NULL</span>)</span><br><span class="line">		pvalue = (<span class="type">char</span> *)empty_str;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		*last = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	DEBUGP(<span class="string">&quot;value=%s\n&quot;</span>, pvalue);</span><br><span class="line">	<span class="comment">// 将value写入到mibvalue中</span></span><br><span class="line">	<span class="keyword">if</span> (string_to_mib_ex(mibvalue, pvalue, mib_table[i].type, mib_table[i].size, <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	<span class="comment">// 将mibvalue设置到对应的mib_table项中</span></span><br><span class="line">	<span class="keyword">if</span> (!MIB_SET(mib_table[i].id, mibvalue)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Set MIB[%s] error!\n&quot;</span>, mib_table[i].name);</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是通过字符串操作解析出name和value，通过name找到对应的mib项，调用<code>MIB_SET</code>将value设置到该mib项中，<code>MIB_SET</code>其实就是调用了之前用来设置mib项的<code>mib_set</code>或者<code>_mib_set</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">MIB_SET</span><span class="params">(<span class="type">int</span> id, <span class="type">void</span> *value)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (load_to_configd)</span><br><span class="line">		<span class="keyword">return</span> mib_set(id, value);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> _mib_set(id, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于mib_chain的设置稍微复杂些，但基本操作都是差不多，这里不细说了。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>综上，配置文件中的内容会在<code>mib_init</code>时读出来，覆盖默认的mib配置项。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/14/%E5%90%8C%E6%AD%A5%E3%80%81%E4%BA%92%E6%96%A5%E4%B8%8E%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/myicon.jpg">
      <meta itemprop="name" content="LinWenXin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of WenXinLin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/14/%E5%90%8C%E6%AD%A5%E3%80%81%E4%BA%92%E6%96%A5%E4%B8%8E%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">同步、互斥与通信(嵌入式系统与应用)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-14 20:00:33" itemprop="dateCreated datePublished" datetime="2023-11-14T20:00:33+08:00">2023-11-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="同步、互斥与通信"><a href="#同步、互斥与通信" class="headerlink" title="同步、互斥与通信"></a>同步、互斥与通信</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>多任务系统中任务之间&#x2F;任务与ISR的关系</p>
<ul>
<li>相互独立：仅竞争CPU资源</li>
<li>互斥：竞争除CPU外的其他资源</li>
<li>同步：<strong>协调</strong>彼此运行的<strong>步调</strong>，保证协同运行的各个任务具有正确的执行次序</li>
<li>通信：彼此间<strong>传递数据或信息</strong>，以协同完成某项工作</li>
</ul>
<p>任务能以以下方式与中断处理程序或其他任务进行同步或通信：</p>
<ul>
<li>单向同步或通信：一个任务与另一个任务或一个ISR同步或通信</li>
<li>双向同步或通信：两个任务相互同步或通信。双向同步不能在任务与ISR之间进行，因为ISR不能等待</li>
</ul>
<p>在单处理器平台上，嵌入式操作系统内核提供的同步、互斥与通信机制主要包括：</p>
<ul>
<li>互斥：互斥信号量（mutex）</li>
<li>同步：信号量（semaphore）、事件（组）（Flag\event group）、异步信号（asynchronous signal）</li>
<li>消息通信：邮箱（mailbox）、消息队列（message queue）</li>
<li>非结构化数据交换和同步：管道（pipe）</li>
</ul>
<p>以下一些机制也可用于同步与通信（在单处理器或多处理器系统中）</p>
<ul>
<li>全局变量，共享内存，Sockets，远程过程调用（Remote Procedure Call），自旋锁</li>
</ul>
<p>嵌入式多任务系统中，任务间的耦合程度是不一样的</p>
<ul>
<li>耦合度：对任务之间关联程度的度量</li>
<li>耦合程度较高：任务之间需要进行大量的通信，相应的系统开销较大；</li>
<li>耦合程度较低：任务之间不存在通信需求，其间的同步关系很弱甚至不需要同步或互斥，系统开销较小</li>
</ul>
<p>任务划分准则之一：耦合度高的模块尽量划分在同一任务内</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>这一部分可以查看操作系统</p>
<h3 id="信号量的种类及用途"><a href="#信号量的种类及用途" class="headerlink" title="信号量的种类及用途"></a>信号量的种类及用途</h3><p>信号量用于实现任务与任务之间、任务与中断处理程序之间的<strong>同步与互斥</strong></p>
<ul>
<li><p>互斥信号量：用于解决互斥问题。它比较特殊，可能会引起优先级反转问题。</p>
</li>
<li><p>二值信号量：用于解决同步问题</p>
</li>
<li><p>计数信号量：用于解决资源计数问题</p>
</li>
</ul>
<p>将信号量进行种类细分，可以根据其用途，在具体实现时做专门处理，提高执行效率和可靠性</p>
<h3 id="互斥信号量"><a href="#互斥信号量" class="headerlink" title="互斥信号量"></a>互斥信号量</h3><p>用互斥信号量保护的代码区称作“<strong>临界区</strong>”，临界区代码通常用于对<strong>共享资源</strong>的访问。<strong>互斥信号量的值被初始化成1</strong>，表明目前没有任务进入“临界区”，但最多只有一个任务可以进入“临界区”</p>
<p>共享资源可能是一段存储器空间、一个数据结构或I&#x2F;O设备，也可能是被两个或多个并发任务<strong>共享的任何内容</strong></p>
<p>使用互斥信号量可以实现<strong>对共享资源的串行访问</strong>，保证只有成功地获取互斥信号量的任务才能够释放它</p>
<p><strong>互斥信号量的值被初始化成1</strong>，表明目前没有任务进入“临界区”，但最多只有一个任务可以进入“临界区”</p>
<p>第一个试图进入“临界区”的任务将成功获得互斥信号量，而随后试图进入用同一信号量保护的临界区的所有其他任务就必须等待</p>
<p>当任务离开“临界区”时，它将释放信号量并允许正在等待该信号量的任务进入“临界区”</p>
<p>互斥信号量是一种特殊的二值信号量，一般它支持<strong>所有权、递归访问、任务删除安全</strong>等概念和一些<strong>避免优先级反转、饥饿、死锁等互斥所固有问题的协议</strong></p>
<p><img src="/images/blog_images/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%80%9A%E4%BF%A1/%E4%BA%92%E6%96%A5%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%8A%B6%E6%80%81%E5%9B%BE.png" alt="互斥信号量状态图"></p>
<p><strong>所有权</strong>：当一个任务通过获取互斥信号量而将其锁定时，得到该互斥信号量的所有权。相反，当一个任务释放信号量时，失去对其的所有权</p>
<p>当一个任务拥有互斥信号量时，其他的任务不能再锁定或释放它，即任务要释放互斥信号量，必须事前先获取该信号量</p>
<h4 id="嵌套（递归）资源访问"><a href="#嵌套（递归）资源访问" class="headerlink" title="嵌套（递归）资源访问"></a>嵌套（递归）资源访问</h4><p>如果Task1调用RoutineA，而RoutineA又调用RoutineB，并且三者访问相同的共享资源，就发生了递归共享资源的访问同步问题</p>
<p>一个递归的互斥信号量允许嵌套锁定互斥信号量，而不引起死锁</p>
<p>每个获取信号量的调用必须与释放信号量的调用相匹配</p>
<p>用于<strong>同步的信号量不支持嵌套</strong>访问</p>
<h4 id="删除安全"><a href="#删除安全" class="headerlink" title="删除安全"></a>删除安全</h4><p>在一个受信号量保护的临界区，经常需要保护在临界区执行的任务不会被意外地删除</p>
<p>删除一个在临界区执行的任务可能引起意想不到的后果，造成保护资源的信号量不可用，可能导致资源处于破坏状态，也就导致了其它所有要访问该资源的任务无法得到满足</p>
<p>为避免任务在临界区执行时不被意外删除：</p>
<ul>
<li>提供“任务保护”和“解除任务保护”原语对</li>
<li>同时，为互斥信号量提供“删除安全”选项。在创建信号量的时候使用这个选项，当应用每次获取信号量时<strong>隐含</strong>地使能“任务保护”功能，当每次释放信号量时隐含地使用“解除任务保护”功能</li>
</ul>
<h4 id="各种互斥机制比较-star2"><a href="#各种互斥机制比较-star2" class="headerlink" title="各种互斥机制比较:star2:"></a>各种互斥机制比较:star2:</h4><table>
<thead>
<tr>
<th>比较项目</th>
<th>关中断</th>
<th>使用测试并置位指令</th>
<th>禁止任务切换</th>
<th>使用信号量</th>
</tr>
</thead>
<tbody><tr>
<td>锁定范围</td>
<td><strong>互斥力度最强</strong>，锁定所有外部可屏蔽中断，凡是以中断形式到达的外部事件以及与之相关联的任务或处理过程均得不到执行</td>
<td>凡是使用该指令访问共享资源的代码</td>
<td>所有任务</td>
<td>只影响竞争共享资源的任务</td>
</tr>
<tr>
<td>对系统响应时间的影响</td>
<td>如果关中断的时间较长，对系统的响应性能有很大影响</td>
<td>较小</td>
<td>如果禁止切换的时间过长，则影响系统的响应性能</td>
<td>对系统响应性能有一定影响，<strong>可能导致优先级反转</strong></td>
</tr>
<tr>
<td>实现时的系统开销</td>
<td>小</td>
<td>小</td>
<td>小</td>
<td>较大</td>
</tr>
<tr>
<td>注意事项</td>
<td>关中断时间要尽量短</td>
<td>不是所以处理器都具有这种指令，影响可移植性</td>
<td>关调度的时间要尽量短</td>
<td>需采用一定的策略解决优先级反转问题</td>
</tr>
</tbody></table>
<h3 id="二值信号量"><a href="#二值信号量" class="headerlink" title="二值信号量"></a>二值信号量</h3><p>二值信号量主要用于任务与任务之间、任务与中断服务程序之间的同步</p>
<ul>
<li>用于同步的二值信号量初始值为0，表示同步事件尚未产</li>
<li>任务申请信号量以等待该同步事件的发生</li>
<li>另一个任务或ISR到达同步点时，释放信号量（将其值设置为1）表示同步事件已发生，以唤醒等待的任务</li>
</ul>
<h3 id="计算信号量"><a href="#计算信号量" class="headerlink" title="计算信号量"></a>计算信号量</h3><p>计数信号量用于控制系统中共享资源的多个实例的使用，允许多个任务同时访问同一种资源的多个实例</p>
<p>计数信号量被初始化为n（非负整数），n为该种共享资源的数目</p>
<p>常用于生产者和消费者问题，mutex empty full</p>
<h3 id="信号量机制的主要数据结构"><a href="#信号量机制的主要数据结构" class="headerlink" title="信号量机制的主要数据结构"></a>信号量机制的主要数据结构</h3><p><img src="/images/blog_images/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%80%9A%E4%BF%A1/%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%BB%E8%A6%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="信号量机制的主要数据结构"></p>
<p>信号量控制块：管理所有创建的信号量，内核在系统运行时动态分配和回收信号量控制块</p>
<p>互斥和二值信号量控制块结构: Binary_Semaphore_Control_Block</p>
<ul>
<li>wait_queue 任务等待队列</li>
<li>attributes 信号量属性<ul>
<li>lock_nesting_behavior试图嵌套获得时的规则</li>
<li>wait_discipline 任务等待信号量的方式（FCFS还是优先级等）</li>
<li>priority_ceiling 优先级天花板值</li>
</ul>
</li>
<li>lock 是否被占有</li>
<li>holder 拥有者</li>
<li>nest_count 嵌套层数</li>
</ul>
<p>计数信号量控制结构Counting_Semaphore_Control_Block</p>
<ul>
<li><p>wait_queue 任务等待队列</p>
</li>
<li><p>attributes 计数信号量属性</p>
<ul>
<li><p>maximum_count    最大计数值</p>
</li>
<li><p>wait_discipline 任务等待信号量的方式</p>
</li>
</ul>
</li>
<li><p>count 当前计数值</p>
</li>
</ul>
<h4 id="信号量内部实现机制实例说明-µC-OS-II"><a href="#信号量内部实现机制实例说明-µC-OS-II" class="headerlink" title="信号量内部实现机制实例说明 µC&#x2F;OS-II"></a>信号量内部实现机制实例说明 µC&#x2F;OS-II</h4><p>事件控制块ECB：同步与通信机制的基本数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">INT8U OSEventType;<span class="comment">//事件类型</span></span><br><span class="line">INT8U OSEventGrp;<span class="comment">//等待任务所在的组 与等待任务列表是一对的</span></span><br><span class="line">INT16U OSEventCnt;<span class="comment">//计数器（信号量）</span></span><br><span class="line"><span class="type">void</span> *OSEventPtr;<span class="comment">//指向消息或消息队列的指针</span></span><br><span class="line">INT8U OSEventTbl[OS_EVENT_TBL_SIZE];<span class="comment">//等待任务列表</span></span><br><span class="line">&#125;OS_EVENT;</span><br></pre></td></tr></table></figure>

<p><img src="/images/blog_images/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%80%9A%E4%BF%A1/%E4%BA%8B%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97%E4%B8%8E%E4%BB%BB%E5%8A%A1%E7%AD%89%E5%BE%85%E5%88%97%E8%A1%A8%E5%85%B3%E7%B3%BB.png" alt="事件控制块与任务等待列表关系"></p>
<p>当一个事件发生后，<strong>等待事件</strong>列表中优先级最高的任务（即在.OSEventTbl[]&amp;OSEventGrp中所有被置1的位中优先级数值最小的任务）得到该事件</p>
<p><img src="/images/blog_images/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%80%9A%E4%BF%A1/%E7%AD%89%E5%BE%85%E4%BA%8B%E4%BB%B6%E5%88%97%E8%A1%A8.png" alt="等待事件列表"></p>
<p>当.OSEventTbl[n]中的任何一位为1时，OSEventGrp中的第n位为1。 与任务就绪列表类似！</p>
<p>将一个任务插入到等待事件的任务列表中 与将一个任务插入到就绪列表中的操作类似！</p>
<p>从等待事件的任务列表中使任务脱离等待状态 与将任务从就绪列表中清除的操作类似！</p>
<p>在等待事件的任务列表中查找优先级最高的任务 与查找优先级最高的就绪任务的操作类似！</p>
<p>空闲事件控制块，也是从空的结构里面选一个装入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OS_InitEventList</span> <span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>

<p>返回类型：无 参数：无</p>
<p>功能：初始化事件控制块ECB链，形成空闲ECB链表，所在文件os_core.c</p>
<h3 id="典型的信号量操作"><a href="#典型的信号量操作" class="headerlink" title="典型的信号量操作"></a>典型的信号量操作</h3><h4 id="创建信号量"><a href="#创建信号量" class="headerlink" title="创建信号量"></a>创建信号量</h4><p>功能：根据应用传递的参数创建一个信号量</p>
<p>参数：信号量的名字、属性和初始值等。</p>
<p>内核动作：</p>
<ul>
<li>从空闲信号量控制块链中分配一个信号量控制块，并初始化信号量属性。</li>
<li>创建成功时，为其分配唯一的ID号返回给应用。</li>
<li>如果已创建信号量数量已达到用户配置的最大数量，就返回错误。</li>
</ul>
<p>信号量的属性</p>
<ul>
<li>信号量类型</li>
<li>任务等待信号方式<ul>
<li>先进先出</li>
<li>优先级</li>
</ul>
</li>
<li>优先级反转问题的解决方法（只适用于互斥信号量）<ul>
<li>优先级继承算法</li>
<li>优先级天花板算法，需给出所有可能获得此信号量的任务中优先级最高的任务的优先级</li>
<li>与任务删除安全、递归访问以及解决优先级反转的策略相关的参数</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">OS_EVENT *<span class="title function_">OSSemCreate</span> <span class="params">(INT16U cnt)</span></span><br><span class="line">&#123;</span><br><span class="line"> OS_EVENT *pevent;</span><br><span class="line"> pevent = OSEventFreeList;<span class="comment">//从空闲事件控制块链中取得一个ECB</span></span><br><span class="line"> <span class="keyword">if</span> (OSEventFreeList != (OS_EVENT *)<span class="number">0</span>) &#123;</span><br><span class="line"> OSEventFreeList = (OS_EVENT *)OSEventFreeList-&gt;OSEventPtr;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (pevent != (OS_EVENT *)<span class="number">0</span>) &#123; <span class="comment">//初始化ECB的各个域</span></span><br><span class="line">  pevent-&gt;OSEventType = OS_EVENT_TYPE_SEM; <span class="comment">//事件类型为信号量</span></span><br><span class="line">  pevent-&gt;OSEventCnt = cnt; <span class="comment">//信号量的初始计数值</span></span><br><span class="line">  pevent-&gt;OSEventPtr = (<span class="type">void</span> *)<span class="number">0</span>;</span><br><span class="line">  OS_EventWaitListInit(pevent); <span class="comment">//初始化等待任务列表</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> (pevent); <span class="comment">//调用者需检查返回值，如果为NULL则表示建立失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取（申请）信号量"><a href="#获取（申请）信号量" class="headerlink" title="获取（申请）信号量"></a>获取（申请）信号量</h4><p>功能：试图获得应用指定的信号量。</p>
<ul>
<li>if   信号量的值大于0</li>
<li>then  将信号量的值减1</li>
<li>else  根据接收信号量的选项，将任务放到等待队列中，或是直接返回</li>
</ul>
<p>当所申请的信号量不能被立即获得时，可以有以下几种选择：</p>
<ul>
<li>永远等待</li>
<li>不等待，立即返回，并返回一个错误状态码</li>
<li>指定等待时限（可有效避免死锁）</li>
</ul>
<p>注意：</p>
<ul>
<li>不允许在ISR中选择等待</li>
<li>当任务选择等待时，将被按FIFO或优先级顺序放置在等待队列中</li>
</ul>
<p>如果任务等待一个使用<strong>优先级继承算法</strong>的互斥信号量，且它的优先级高于当前正占有此信号量的任务的优先级，那么占有信号量的任务将继承这个被阻塞的任务的优先级。</p>
<p>如果任务成功地获得一个采用<strong>优先级天花板算法</strong>的互斥信号量，它的优先级又低于优先级天花板，那么它的优先级将被抬升至天花板。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取（等待）一个信号量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OSSemPend</span> <span class="params">(OS_EVENT *pevent, INT16U timeout, INT8U *err)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (pevent-&gt;OSEventCnt &gt; <span class="number">0</span>) &#123; <span class="comment">//信号量值大于0，成功获得信号量并返回</span></span><br><span class="line">  pevent-&gt;OSEventCnt--;</span><br><span class="line">  *err = OS_NO_ERR;</span><br><span class="line">  <span class="keyword">return</span>;&#125;</span><br><span class="line"> OSTCBCur-&gt;OSTCBStat |= OS_STAT_SEM; <span class="comment">//设置任务状态为等待信号量</span></span><br><span class="line"> OSTCBCur-&gt;OSTCBDly = timeout; <span class="comment">//设置等待时限</span></span><br><span class="line"> OS_EventTaskWait(pevent);<span class="comment">//将任务放置到信号量的等待列表中</span></span><br><span class="line"> OS_Sched(); <span class="comment">//内核实施任务调度，系统切换到另一就绪任务执行</span></span><br><span class="line"> <span class="keyword">if</span> (OSTCBCur-&gt;OSTCBStat &amp; OS_STAT_SEM) &#123; <span class="comment">//判断任务恢复执行的原因，如果等待时限超时但仍然未获得信号量，则返回超时信息</span></span><br><span class="line">  OSEventTO(pevent);</span><br><span class="line">  *err = OS_TIMEOUT;</span><br><span class="line">  <span class="keyword">return</span>;&#125;</span><br><span class="line"> OSTCBCur-&gt;OSTCBEventPtr = (OS_EVENT *)<span class="number">0</span>;</span><br><span class="line"> *err = OS_NO_ERR; <span class="comment">//任务由于获得信号量而恢复执行，本调用成功返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无等待地请求</span></span><br><span class="line">INT16U <span class="title function_">OSSemAccept</span> <span class="params">(OS_EVENT *pevent)</span></span><br><span class="line">&#123;</span><br><span class="line"> INT16U cnt;</span><br><span class="line"> cnt = pevent-&gt;OSEventCnt;</span><br><span class="line"> <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  pevent-&gt;OSEventCnt--;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> (cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：即使不能成功获得信号量（返回值为0），调用者也不会被阻塞。此函数可以在中断处理程序中使用。</p>
<h4 id="释放信号量"><a href="#释放信号量" class="headerlink" title="释放信号量"></a>释放信号量</h4><p>功能：释放一个应用指定的信号量。</p>
<ul>
<li>if   没有任务等待这个信号量</li>
<li>then  信号量的值加1</li>
<li>else  将信号量分配给一个等待任务（将相应的任务移出等待队列，使其就绪）</li>
</ul>
<p>如果使用了优先级继承或优先级天花板算法，那么执行该功能（系统调用）的任务的优先级将恢复到原来的高度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INT8U <span class="title function_">OSSemPost</span> <span class="params">(OS_EVENT *pevent)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (pevent-&gt;OSEventGrp!=<span class="number">0x00</span>) &#123; <span class="comment">//如果有任务在等待该信号量</span></span><br><span class="line">  OS_EventTaskRdy(pevent, (<span class="type">void</span> *)<span class="number">0</span>, OS_STAT_SEM); <span class="comment">//使等待任务列表中优先级最高的任务就绪</span></span><br><span class="line">  OS_Sched(); <span class="comment">//内核实施任务调度</span></span><br><span class="line">  <span class="keyword">return</span> (OS_NO_ERR);<span class="comment">//成功返回</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (pevent-&gt;OSEventCnt &lt; <span class="number">65535</span>) &#123;<span class="comment">//如果没有任务等待该信号量，并且信号量的值未溢出</span></span><br><span class="line">  pevent-&gt;OSEventCnt++; <span class="comment">//信号量的值加1</span></span><br><span class="line">  <span class="keyword">return</span> (OS_NO_ERR);<span class="comment">//成功返回</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> (OS_SEM_OVF);<span class="comment">//信号量溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除信号量"><a href="#删除信号量" class="headerlink" title="删除信号量"></a>删除信号量</h4><p>功能：从系统中删除应用指定的一个信号量</p>
<p>内核动作：将信号量控制块返还给系统</p>
<p>删除信号量的不一定是创建信号量的任务</p>
<p><strong>如果有任务正在等待</strong>获得该信号量，执行此功能将使所有等待这个信号量的任务回到就绪队列中，且返回一个状态码指示该信号量已被删除</p>
<p>企图获取已删除的信号量将返回一个错误；</p>
<p>在互斥信号量正被使用时（已经被某任务获取），不能删除它。因为该信号量正在保护一个共享资源或临界代码段，该动作可能造成数据崩溃或其他严重问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">OS_EVENT *<span class="title function_">OSSemDel</span><span class="params">(OS_EVENT *pevent, INT8U opt, INT8U *err)</span></span><br><span class="line">&#123;</span><br><span class="line"> BOOLEAN tasks_waiting;</span><br><span class="line"> <span class="keyword">if</span>(pevent-&gt;OSEventGrp!=<span class="number">0x00</span>&#123;<span class="comment">//根据是否有任务在等待信号量设置等待标志</span></span><br><span class="line">  tasks_waiting=TRUE;</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  tasks_waiting=FALSE;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">  <span class="keyword">case</span> OS_DEL_NO_PEND:<span class="comment">//如果有任务等待信号量则不删除信号量</span></span><br><span class="line">   <span class="keyword">if</span>(task_waiting==FALSE&#123;<span class="comment">//没有任务等待，释放ECB回空闲链</span></span><br><span class="line">    pevent-&gt;OSEventType=OS_EVENT_TYPE_UNUSED;</span><br><span class="line">    pevent-&gt;OSEventPtr=OSEventFreeList;</span><br><span class="line">     OSEventFreeList=pevent;<span class="comment">//调整空闲ECB链头指针</span></span><br><span class="line">    *err=OS_NO_ERR;</span><br><span class="line">    <span class="keyword">return</span>((OS_EVENT)<span class="number">0</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     *err=OS_ERR_TASK_WAITING;<span class="comment">//有任务等待，删除信号量失败</span></span><br><span class="line">     <span class="keyword">return</span>(pevent);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">case</span> OS_DEL_ALWAYS:<span class="comment">//无论有无任务等待都删除信号量</span></span><br><span class="line">    <span class="comment">//将等待列表中的每个任务都设置成就绪</span></span><br><span class="line">   <span class="keyword">while</span>(pevent-&gt;OSEventGrp!=<span class="number">0x00</span>)&#123;</span><br><span class="line">   OS_EventTaskRdy(pevent,(<span class="type">void</span> *)<span class="number">0</span>, OS_STAT_SEM);&#125;</span><br><span class="line">   <span class="comment">//释放该信号量的ECB回空闲控制块链</span></span><br><span class="line">   pevent-&gt;OSEventType=OS_EVENT_TYPE_UNUSED;</span><br><span class="line">   pevent-&gt;OSEventFreeList;</span><br><span class="line">    OSEventFreeList=pevent;</span><br><span class="line">   <span class="comment">//如果之前有任务等待信号量，内核实施任务调度</span></span><br><span class="line">   <span class="keyword">if</span>(tasks_waiting==TRUE)&#123;OS_Sched();&#125;</span><br><span class="line">   *err=OS_NO_ERR;</span><br><span class="line">   <span class="keyword">return</span>((OS_EVENT *)<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">   *err=OS_ERR_INVALID_OPT;</span><br><span class="line">   <span class="keyword">return</span>(pevent);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="清除信号量的任务等待列表"><a href="#清除信号量的任务等待列表" class="headerlink" title="清除信号量的任务等待列表"></a>清除信号量的任务等待列表</h4><p>为了清除等待一个信号量的所有任务，某些内核支持Flush操作，以便释放信号量等待任务列表中的所有任务。当多个任务的执行必须在某些点相遇时，需要这样的机制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">signalTask --Flush--&gt; f[二值信号量初始值0]</span><br><span class="line">f --&gt; task1</span><br><span class="line">f --&gt; task2</span><br></pre></td></tr></table></figure>

<h2 id="邮箱和消息队列"><a href="#邮箱和消息队列" class="headerlink" title="邮箱和消息队列"></a>邮箱和消息队列</h2><h3 id="通信方式概述"><a href="#通信方式概述" class="headerlink" title="通信方式概述"></a>通信方式概述</h3><h4 id="直接通信"><a href="#直接通信" class="headerlink" title="直接通信"></a>直接通信</h4><p>通信双方必须明确知道彼此  </p>
<p>Send (P，message) – 发送一个消息到任务P</p>
<p>Receive(Q，message) – 从任务Q接收一个消息</p>
<p>直接通信具有如下特性</p>
<ul>
<li>每对任务之间仅存在一个链接</li>
<li>链接可以是单向，也可以是双向</li>
</ul>
<h4 id="间接通信"><a href="#间接通信" class="headerlink" title="间接通信"></a>间接通信</h4><p>通信双方不需要指出消息的来源或去向，通过中间机制通信</p>
<p>send(A，message) – 发送一个消息给邮箱A</p>
<p>receive(A，message) – 从邮箱A接收一个消息</p>
<p>间接通信具有如下特性</p>
<ul>
<li>只有当任务共享一个公共邮箱时链接才建立</li>
<li>一个链接可以与多个任务相联系</li>
<li>每个任务可以使用几个通信链接</li>
</ul>
<h3 id="邮箱和消息队列概述"><a href="#邮箱和消息队列概述" class="headerlink" title="邮箱和消息队列概述"></a>邮箱和消息队列概述</h3><p>消息：<strong>内存空间中一段长度可变的缓冲区</strong>，其长度和内容均可以由用户定义，其内容可以是实际的数据、数据块的指针或空</p>
<p>消息队列：属于<strong>间接通信方式</strong></p>
<p>消息机制在任务之间、任务和ISR（中断服务程序）之间提供<strong>消息传递或同步</strong></p>
<p>对消息内容的解释由应用完成</p>
<ul>
<li>从<strong>操作系统</strong>观点看，消息没有定义的格式，所有的消息都是字节流，没有特定的含义。</li>
<li>从<strong>应用</strong>观点看，根据应用定义的消息格式，消息被解释成特定的含义。</li>
<li>应用可以只把消息当成一个标志，这时消息机制用于实现<strong>同步</strong></li>
</ul>
<p>一些操作系统内核把消息进一步分为：邮箱和消息队列</p>
<ul>
<li>邮箱仅能存放<strong>单条</strong>消息，它提供了一种低开销的机制来传送信息。每个邮箱可以保存一条大小为若干个字节的消息(ucosIII 取消)</li>
<li>消息队列可存放<strong>若干</strong>消息，提供了一种任务间缓冲通信的方法</li>
</ul>
<p>消息机制可支持<strong>定长与可变长度</strong>两种模式的消息，可变长度的消息队列需要对队列中的每一条消息增加<strong>额外的存储开销</strong></p>
<ul>
<li><p>创建邮箱             OSMboxCreate</p>
</li>
<li><p>删除邮箱             OSMboxDel</p>
</li>
<li><p>申请消息             OSMboxPend</p>
</li>
<li><p>发送消息             OSMboxPost</p>
</li>
<li><p>申请消息（不带阻塞） OSMboxAccept</p>
</li>
<li><p>获取邮箱信息         OSMboxQuery</p>
</li>
</ul>
<h5 id="OSMboxCreate函数"><a href="#OSMboxCreate函数" class="headerlink" title="OSMboxCreate函数"></a>OSMboxCreate函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OS_EVENT *<span class="title function_">OSMboxCreate</span> <span class="params">(<span class="type">void</span> *pmsg)</span></span><br></pre></td></tr></table></figure>

<p>返回类型：指向事件控制块的指针</p>
<p>参数：存储消息的指针pmsg；</p>
<p>功能：创建一个邮箱</p>
<p>所在文件：os_mbox.c</p>
<h3 id="消息队列机制的主要数据结构"><a href="#消息队列机制的主要数据结构" class="headerlink" title="消息队列机制的主要数据结构"></a>消息队列机制的主要数据结构</h3><p><img src="/images/blog_images/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%80%9A%E4%BF%A1/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8F%82%E6%95%B0%E5%92%8C%E6%94%AF%E6%8C%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="消息队列及其相关的参数和支持数据结构"></p>
<p><img src="/images/blog_images/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%80%9A%E4%BF%A1/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%8A%B6%E6%80%81%E5%9B%BE.png" alt="消息队列状态图"></p>
<p>消息队列控制块</p>
<ul>
<li>管理所有创建的消息队列，系统运行时<strong>动态分配和回收消息队列控制块</strong></li>
</ul>
<p>消息队列缓冲区：<strong>存放发送到该队列的消息</strong></p>
<ul>
<li>接收者从缓冲区中取出消息</li>
<li>消息的发送或接收有两种方法（影响消息缓冲区结构）<ul>
<li>将数据从发送任务的空间<strong>完全拷贝</strong>到接收任务的空间中（效率较低，执行时间与消息大小有关）</li>
<li>只传递指向数据<strong>存储空间的指针</strong>（提高系统性能，一般情况）</li>
</ul>
</li>
</ul>
<p><img src="/images/blog_images/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%80%9A%E4%BF%A1/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png" alt="消息队列的内存区域"></p>
<p>发送和接收消息的消息拷贝和内存使用</p>
<ul>
<li>这种消息传递方法效率低、占用空间大</li>
<li>一种效率更高的方式是<strong>传递消息指针</strong></li>
</ul>
<table>
<thead>
<tr>
<th>消息队列控制块</th>
<th>消息队列缓冲区（环形缓冲）</th>
</tr>
</thead>
<tbody><tr>
<td>wait_queue</td>
<td></td>
</tr>
<tr>
<td>max_message_count</td>
<td></td>
</tr>
<tr>
<td>numer_of_message</td>
<td></td>
</tr>
<tr>
<td>wait_descipline</td>
<td></td>
</tr>
<tr>
<td>queue_state</td>
<td>队头，消息队列空间头部</td>
</tr>
<tr>
<td>queue_in</td>
<td>消息头 指向message</td>
</tr>
<tr>
<td>queue_out</td>
<td>消息尾</td>
</tr>
<tr>
<td>queue_end</td>
<td>队尾，消息队列空间尾部</td>
</tr>
</tbody></table>
<p>queue_in~out：number_of_message</p>
<p>queue_start~end：max_message_count</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">os_q</span> &#123;</span>         <span class="comment">/* QUEUE CONTROL BLOCK */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">os_q</span>   *<span class="title">OSQPtr</span>;</span>      <span class="comment">/* 空闲链表中当next指针使用  */</span></span><br><span class="line">    <span class="type">void</span>         **OSQStart;     <span class="comment">/* 消息队列缓冲区的起始地址 */</span></span><br><span class="line">    <span class="type">void</span>         **OSQEnd;       <span class="comment">/* 消息队列缓冲区的结束地址 */</span></span><br><span class="line">    <span class="type">void</span>         **OSQIn;          <span class="comment">/* 放消息的指针  */</span></span><br><span class="line">    <span class="type">void</span>         **OSQOut;       <span class="comment">/* 取消息的指针 */</span></span><br><span class="line">    INT16U      OSQSize;       <span class="comment">/* 消息队列缓冲区的容量 */</span></span><br><span class="line">    INT16U      OSQEntries;     <span class="comment">/* 当前放置在消息队列缓冲区中的消息数目  */</span></span><br><span class="line">&#125; OS_Q;</span><br></pre></td></tr></table></figure>

<p>消息队列机制即要用到ECB，还要用到QCB</p>
<h3 id="典型的消息队列操作"><a href="#典型的消息队列操作" class="headerlink" title="典型的消息队列操作"></a>典型的消息队列操作</h3><ul>
<li>创建消息队列</li>
<li>发送普通消息</li>
<li>发送紧急消息</li>
<li>发送广播消息</li>
<li>接收消息</li>
<li>删除消息队列</li>
<li>获取有关消息队列的各种信息</li>
</ul>
<p>队列管理函数调用</p>
<ul>
<li><p>创建消息队列             OSQCreate</p>
</li>
<li><p>删除消息队列             OSQDel</p>
</li>
<li><p>接收消息                 OSQPend</p>
</li>
<li><p>发送消息          OSQPost</p>
</li>
<li><p>发送广播消息             OSQFlush</p>
</li>
<li><p>获取消息队列信息             OSQQuery</p>
</li>
</ul>
<h4 id="创建消息队列"><a href="#创建消息队列" class="headerlink" title="创建消息队列"></a>创建消息队列</h4><p>创建消息队列时，分配队列控制块,调用时可以指定如下参数：</p>
<ul>
<li>消息的最大长度</li>
<li>每个消息队列中最多的消息数</li>
<li>消息队列的属性<ul>
<li>任务等待消息时的排队方式：FIFO或PRIORITY</li>
</ul>
</li>
</ul>
<p>系统为新创建的消息队列分配唯一的ID</p>
<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p><strong>普通消息放队尾，紧急消息放队首</strong></p>
<p>如果有任务正在等待消息（即消息队列为空），则普通消息发送和紧急消息发送的执行效果是一样的。任务从等待队列移到就绪队列中，消息被拷贝到任务提供的缓冲区中（或者由接收任务得到指向消息的指针）。</p>
<p>如果没有任务等待，发送普通消息将消息放在队列尾，而发送紧急消息将消息放在队列头。</p>
<p>如果发送消息时队列已被填满，则不同的操作系统可能采取不同的处理办法：</p>
<ul>
<li>挂起试图向已满的消息队列中发送消息的任务（不适用于中断服务程序）</li>
<li>简单地丢弃该条消息并向调用者返回错误信息</li>
</ul>
<h4 id="广播消息"><a href="#广播消息" class="headerlink" title="广播消息"></a>广播消息</h4><p>在此之前所有试图从队列中接收消息的任务此时都将获得相同的消息。该功能拷贝消息到各任务的消息缓冲中（或者让所有的等待任务得到指向消息的指针），并唤醒所有的等待任务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INT8U <span class="title function_">OSQPost</span> <span class="params">(OS_EVENT *pevent, <span class="type">void</span> *pmsg)</span></span><br></pre></td></tr></table></figure>

<p>返回类型：出错信息<br>参数：事件控制块的指针pevent，消息指针pmsg；<br>功能：向一个消息队列放置一条消息<br>所在文件：os_q.c</p>
<h4 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h4><p>如果<strong>指定的消息队列中有消息</strong>，则将其中的第一条消息拷贝到调用者的缓冲区（或者将第一条消息指针传递给调用者），并从消息队列中删除它。</p>
<p>如果<strong>此时消息队列中没有消息</strong>，则可能出现以下几种情况：</p>
<ul>
<li>永远等待消息的到达：等待消息的任务按FIFO或优先级高低顺序排列在等待队列中</li>
<li>等待消息且指定等待时限：等待消息的任务按FIFO或优先级高低顺序排列在等待队列中，但等待时限到了就不再等待，有效预防死锁。</li>
<li>不等待，强制立即返回：ISR必须选这个方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">a(开始) --&gt; b&#123;有效的消息队列&#125;</span><br><span class="line">b --否--&gt; c(返回一个错误状态码)</span><br><span class="line">b --是--&gt; c2&#123;指定列表中有消息?&#125;</span><br><span class="line">c2 --是--&gt; d1[获取信息 拷贝信息内容或传递指针]</span><br><span class="line">c2 --否--&gt; d2&#123;任务接收信息量选项&#125;</span><br><span class="line">d2 --不等待--&gt; e1[立即返回 并返回一个错误状态码]</span><br><span class="line">d2 --指定等待时限--&gt; e2[任务按FIFO或优先级顺序放置在消息等待队列中]</span><br><span class="line">d2 --永远等待--&gt; e2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>等待任务列表有先进先出，优先级的次序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">OSQPend</span> <span class="params">(OS_EVENT *pevent, INT32U timeout, INT8U *perr)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回类型：指向一条消息的指针</li>
<li>参数：事件控制块指针pevent，等待时间timeout，出错信息指针perr；</li>
<li>功能：向一个消息队列申请一条消息</li>
<li>所在文件：os_q.c</li>
</ul>
<h4 id="删除消息队列"><a href="#删除消息队列" class="headerlink" title="删除消息队列"></a>删除消息队列</h4><p>主要动作：从系统中删除指定的消息队列，释放<strong>消息队列控制块</strong>及<strong>消息队列缓冲区</strong>。</p>
<p>任何知道此<strong>消息队列ID</strong>号的代码都可以删除它。</p>
<p>注意：消息队列被删除后，所有等待从这个消息队列接收消息的任务都回到<strong>就绪态</strong>，并得到一个错误信息表明消息队列已被删除。</p>
<h4 id="消息队列的其他典型使用"><a href="#消息队列的其他典型使用" class="headerlink" title="消息队列的其他典型使用"></a>消息队列的其他典型使用</h4><p>紧耦合的单向数据通信：发送任务发送消息后要求一个响应信号，表明接收任务已经成功接收到消息。（是一个同步信号，确认信号）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">subgraph 单向数据通信</span><br><span class="line">a(task1) --&gt; array --&gt; b(task2)</span><br><span class="line">end</span><br><span class="line">subgraph 信号通道</span><br><span class="line">b --&gt; 信号 --&gt; a</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>紧耦合的双向数据通信 ：如果数据需要在任务之间双向流动，则可以采用紧耦合的双向数据通信模式（也称为全双工通信）。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="事件概述"><a href="#事件概述" class="headerlink" title="事件概述"></a>事件概述</h3><p>在嵌入式实时内核中，事件是指一种表明预先定义的系统事件已经发生的机制</p>
<p>事件机制用于任务与任务之间、任务与ISR之间的同步。其主要的特点是可实现一对多的同步</p>
<p>一个事件就是一个标志(Flag)，不具备其它信息。</p>
<p>一个或多个事件构成一个事件集。事件集可以用一个指定长度的变量（比如一个8bit, 16bit或32bit的无符号整型变量，不同的操作系统其具体实现不一样）来表示，而每个事件由在事件集变量中的某一位来代表。</p>
<p>事件及事件集有以下特点：</p>
<ul>
<li>事件间<strong>相互独立</strong></li>
<li>事件仅用于<strong>同步</strong>，不提供数据传输功能</li>
<li>事件<strong>无队列</strong>，即多次发送同一事件，在未经过任何处理的情况下，其效果等同于只发送一次</li>
</ul>
<p>提供事件机制的意义在于：</p>
<ul>
<li>当某任务要与<strong>多个任务或中断服务同步</strong>时，就需要使用事件机制</li>
<li>若任务需要与一组事件中的任意一个发生同步，可称为<strong>独立型同步</strong>（逻辑“或”关系）</li>
<li>任务也可以等待若干事件都发生时才同步，称为<strong>关联型同步</strong>（逻辑“与”关系）</li>
</ul>
<p><img src="/images/blog_images/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%80%9A%E4%BF%A1/%E6%88%96%E5%92%8C%E4%B8%8E%E5%9E%8B%E5%90%8C%E6%AD%A5.png" alt="或和与型同步"></p>
<h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>发送事件集 。指在一次发送过程中发往接收者（比如任务）的一个或多个事件的组合。</p>
<p>待处理事件集。指已被发送到一个接收者但还没有被接收（即正在等待处理）的所有事件的集合。</p>
<p>事件条件。指事件接收者在一次接收过程中期待接收的一个或多个事件的集合。</p>
<ul>
<li>“或”型同步：待处理事件集只要包括事件条件中的任一事件即可满足要求；</li>
<li>“与”型同步：其二是待处理事件集必须包括事件条件中的全部事件方可满足要求。</li>
</ul>
<p><img src="/images/blog_images/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%80%9A%E4%BF%A1/%E5%A4%9A%E4%BA%8B%E4%BB%B6%E5%90%8C%E6%AD%A5.png" alt="多事件同步"></p>
<p>多对多同步：用多个事件的组合发信号给多个任务</p>
<h3 id="事件机制的主要数据结构"><a href="#事件机制的主要数据结构" class="headerlink" title="事件机制的主要数据结构"></a>事件机制的主要数据结构</h3><p>不同操作系统对事件机制的实现有所不同</p>
<p>事件集控制块：管理所有<strong>创建</strong>的事件集，例如：uCOS-II</p>
<p>事件集附属于任务，<strong>不需创建</strong>，其相关参数成为任务控制块的一部分，例如OSEK OS(汽车用，用期望事件集)</p>
<p>事件标志组数据结构 OS_FLAG_GRP</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"> INT8U OSFlagType;<span class="comment">//指示本数据结构的类型</span></span><br><span class="line"> <span class="type">void</span> *OSFlagWaitList;<span class="comment">//指向等待事件标志的任务链表的第一个节点(os_flag_node)</span></span><br><span class="line"> OS_FLAGS OSFlagFlags;<span class="comment">//事件集标志的当前状态</span></span><br><span class="line">&#125;OS_FLAG_GRP;</span><br></pre></td></tr></table></figure>

<p>事件标志节点数据结构 OS_FLAG_NODE</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"> <span class="type">void</span> *OSFlagNodeNext;<span class="comment">//后驱指针</span></span><br><span class="line"> <span class="type">void</span> *OSFlagNodePrev;<span class="comment">//前驱指针</span></span><br><span class="line"> <span class="type">void</span> *OSFlagNodeTCB;<span class="comment">//任务控制块指针</span></span><br><span class="line"> <span class="type">void</span> *OSFlagNodeFlagGrp;<span class="comment">//指回OS_FLAG_GRP结构</span></span><br><span class="line"> OS_FLAGS OSFlagNodeFlags;<span class="comment">//所等待的事件标志组合</span></span><br><span class="line"> INT8U OSFlagNodeWaitType;<span class="comment">//等待类型（与、或）</span></span><br><span class="line">&#125;OS_FLAG_NODE;</span><br></pre></td></tr></table></figure>

<p>事件标志组、事件标志节点及任务控制块之间的关系</p>
<p><img src="/images/blog_images/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%80%9A%E4%BF%A1/%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84%E3%80%81%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E8%8A%82%E7%82%B9%E5%8F%8A%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%9D%97%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="事件标志组、事件标志节点及任务控制块之间的关系"></p>
<h3 id="典型的事件操作"><a href="#典型的事件操作" class="headerlink" title="典型的事件操作"></a>典型的事件操作</h3><ul>
<li>创建事件集</li>
<li>删除事件集</li>
<li>发送事件（集）</li>
<li>接收事件（集）</li>
<li>获取有关事件集的各种信息</li>
</ul>
<h4 id="创建事件集"><a href="#创建事件集" class="headerlink" title="创建事件集"></a>创建事件集</h4><p>申请空闲事件集控制块，设置事件集属性，初始化控制块中的域，分配ID号。事件集相当于标志集</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">OS_FLAG_GRP  *<span class="title function_">OSFlagCreate</span><span class="params">(OS_FLAGS flags, INT8U *err)</span></span><br><span class="line">&#123;</span><br><span class="line"> OS_FLAG_GRP  *pgrp;</span><br><span class="line"> pgrp=OSFlagFreeList;<span class="comment">//获取一个空闲事件标志组结构</span></span><br><span class="line"> <span class="keyword">if</span>(pgrp!=(OS_FLAG_GRP *)<span class="number">0</span>)&#123;<span class="comment">//获取成功，初始化该结构中的域</span></span><br><span class="line">  OSFlagFreeList=(OS_FLAG_GRP *)OSFlagFreeList-&gt;OSFlagWaitList;<span class="comment">//调整空闲结构链头指针</span></span><br><span class="line">  pgrp-&gt;OSFlagType=OS_EVENT_TYPE_FLAG;</span><br><span class="line">  pgrp-&gt;OSFlagFlags=flags;<span class="comment">//初始化当前各事件标志的状态</span></span><br><span class="line">  pgrp-&gt;OSFlagWaitList=(<span class="type">void</span> *)<span class="number">0</span>;<span class="comment">//尚无任务等待事件标志</span></span><br><span class="line">  *err=OS_NO_ERR;</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;*err=OS_FLAG_GRP_DEPLETED;&#125;</span><br><span class="line"> <span class="keyword">return</span>(pgrp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="删除事件集"><a href="#删除事件集" class="headerlink" title="删除事件集"></a>删除事件集</h4><p>回收事件集控制块到空闲链中，等待接收该事件集的任务被恢复就绪</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">OS_FLAG_GRP *<span class="title function_">OSFlagDel</span><span class="params">(OS_FLAG_GRP *pgrp, INT8U opt, INT8U *err)</span></span><br><span class="line">&#123;</span><br><span class="line">  BOOLEAN tasks_waiting;</span><br><span class="line">  OS_FLAG_NODE *pnode;</span><br><span class="line">  <span class="keyword">if</span> (pgrp-&gt;OSFlagWaitList != (<span class="type">void</span> *)<span class="number">0</span>)</span><br><span class="line">    tasks_waiting = TRUE; <span class="comment">//有任务等待</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    tasks_waiting = FALSE; <span class="comment">//无任务等待</span></span><br><span class="line">  <span class="keyword">switch</span> (opt)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> OS_DEL_NO_PEND: <span class="comment">//在无任务等待时才删除事件标志组</span></span><br><span class="line">    <span class="keyword">if</span> (tasks_waiting == FALSE)</span><br><span class="line">    &#123; <span class="comment">//无任务等待，释放控制块到空闲链中</span></span><br><span class="line">      pgrp-&gt;OSFlagType = OS_EVENT_TYPE_UNUSED;</span><br><span class="line">      pgrp-&gt;OSFlagWaitList = (<span class="type">void</span> *)OSFlagFreeList;</span><br><span class="line">      OSFlagFreeList = pgrp;</span><br><span class="line">      *err = OS_NO_ERR;</span><br><span class="line">      <span class="keyword">return</span> ((OS_FLAG_GRP *)<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">//有任务等待，删除失败</span></span><br><span class="line">      *err = OS_ERR_TASK_WAITING;</span><br><span class="line">      <span class="keyword">return</span> (pgrp);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">case</span> OS_DEL_ALWAYS:                             <span class="comment">//无论是否有任务等待，都删除事件标志组</span></span><br><span class="line">    pnode = (OS_FLAG_NODE *)pgrp-&gt;OSFlagWaitList; <span class="comment">//获取等待头节点</span></span><br><span class="line">    <span class="keyword">while</span> (pnode != (OS_FLAG_NODE *)<span class="number">0</span>)</span><br><span class="line">    &#123; <span class="comment">//遍历整个等待任务链，使每个等待任务就绪</span></span><br><span class="line">      OS_FlagTaskRdy(pnode, (OS_FLAGS)<span class="number">0</span>);</span><br><span class="line">      pnode = (OS_FLAG_NODE *)pnode-&gt;OSFlagNodeNext;</span><br><span class="line">    &#125;</span><br><span class="line">    pgrp-&gt;OSFlagType = OS_EVENT_TYPE_UNUSED;</span><br><span class="line">    pgrp-&gt;OSFlagWaitList = (<span class="type">void</span> *)OSFlagFreeList;</span><br><span class="line">    OSFlagFreeList = pgrp; <span class="comment">//释放控制块回空闲链</span></span><br><span class="line">    <span class="keyword">if</span> (tasks_waiting == TRUE)</span><br><span class="line">      OS_Sched(); <span class="comment">//如果之前有任务等待，</span></span><br><span class="line">    *err = OS_NO_ERR;</span><br><span class="line">    内核实施调度</span><br><span class="line">    <span class="keyword">return</span> ((OS_FLAG_GRP *)<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    *err = OS_ERR_INVALID_OPT;</span><br><span class="line">    <span class="keyword">return</span> (pgrp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="发送事件（集）"><a href="#发送事件（集）" class="headerlink" title="发送事件（集）"></a>发送事件（集）</h4><p>调用者（任务或中断）构造一个事件（集），将其发往接收者（比如目标任务）。可能会出现以下几种情况之一：</p>
<ul>
<li>目标任务正在等待的事件条件得到满足，任务就绪</li>
<li>目标任务正在等待的事件条件没有得到满足，该事件（集）被按位“或”操作，保存到目标任务的待处理事件集中，目标任务继续等待</li>
<li>目标任务未等待事件（集），该事件（集）被按位“或”操作，保存到目标任务的待处理事件集中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">OS_FLAGS <span class="title function_">OSFlagPost</span><span class="params">(OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U *err)</span></span><br><span class="line">&#123;</span><br><span class="line">  OS_FLAG_NODE *pnode;</span><br><span class="line">  BOOLEAN sched = FALSE; <span class="comment">//初始化调度标志</span></span><br><span class="line">  OS_FLAGS flags_cur, flags_rdy;</span><br><span class="line"></span><br><span class="line">  pgrp-&gt;OSFlagFlags |= flags;                   <span class="comment">//按位或，置位事件标志</span></span><br><span class="line">  pnode = (OS_FLAG_NODE *)pgrp-&gt;OSFlagWaitList; <span class="comment">//获取任务等待链头节点</span></span><br><span class="line">  <span class="keyword">while</span> (pnode != (OS_FLAG_NODE *)<span class="number">0</span>)</span><br><span class="line">  &#123; <span class="comment">//如果有任务等待，遍历等待链</span></span><br><span class="line">    <span class="keyword">switch</span> (pnode-&gt;OSFlagNodeWaitType)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> OS_FLAG_WAIT_SET_ALL: <span class="comment">//”与”方式等待</span></span><br><span class="line">      flags_rdy = pgrp-&gt;OSFlagFlags &amp; pnode-&gt;OSFlagNodeFlags;</span><br><span class="line">      <span class="keyword">if</span> (flags_rdy == pnode-&gt;OSFlagNodeFlags)</span><br><span class="line">      &#123; <span class="comment">//符合等待条件</span></span><br><span class="line">        <span class="keyword">if</span> (OS_FlagTaskRdy(pnode, flags_rdy) == TRUE)</span><br><span class="line">          sched = TRUE; <span class="comment">//如果任务就绪，设置调度标志</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OS_FLAG_WAIT_SET_ANY: <span class="comment">//”或”方式等待</span></span><br><span class="line">      flags_rdy = pgrp-&gt;OSFlagFlags &amp; pnode-&gt;OSFlagNodeFlags;</span><br><span class="line">      <span class="keyword">if</span> (flags_rdy != (OS_FLAGS)<span class="number">0</span>)</span><br><span class="line">      &#123; <span class="comment">//有满足条件的事件标志</span></span><br><span class="line">        <span class="keyword">if</span> (OS_FlagTaskRdy(pnode, flags_rdy) == TRUE)</span><br><span class="line">          sched = TRUE; <span class="comment">//如果任务就绪，设置调度标志</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pnode = (OS_FLAG_NODE *)pnode-&gt;OSFlagNodeNext; <span class="comment">//下一个等待事件标志的节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sched == TRUE)</span><br><span class="line">    OS_Sched(); <span class="comment">//如果设置了调度标志，则实施调度</span></span><br><span class="line">  *err = OS_NO_ERR;</span><br><span class="line">  <span class="keyword">return</span> (pgrp-&gt;OSFlagFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接收事件（集）"><a href="#接收事件（集）" class="headerlink" title="接收事件（集）"></a>接收事件（集）</h4><p>在接收事件（集）时可以有如下选项</p>
<ul>
<li><p>WAIT 接收事件（集）时可等待</p>
<ul>
<li><p>接收者永远等待，直到事件条件被满足后成功返回；</p>
</li>
<li><p>接收者根据指定的时限等待</p>
</li>
</ul>
</li>
<li><p>NO_WAIT 接收事件（集）时不等待</p>
</li>
</ul>
<p>满足方式</p>
<ul>
<li><p>EVENT_ALL 待处理事件集必须包含事件条件中的全部事件方可满足要求，</p>
<p>即按照“与”条件接收事件</p>
</li>
<li><p>EVENT_ANY 待处理事件集只要包含事件条件中的任一事件即可满足要求，</p>
<p>即按照“或”条件接收事件</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">OS_FLAGS <span class="title function_">OSFlagPend</span><span class="params">(OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *err)</span></span><br><span class="line">&#123;</span><br><span class="line">  OS_FLAG_NODE node; <span class="comment">// OS_FLAG_NODE作为局部变量存在于调用该函数的任务堆栈中</span></span><br><span class="line">  OS_FLAGS flags_cur;</span><br><span class="line">  OS_FLAGS flags_rdy;</span><br><span class="line">  <span class="keyword">switch</span> (wait_type)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> OS_FLAG_WAIT_SET_ALL: <span class="comment">//任务以“与”方式等待事件标志</span></span><br><span class="line">    flags_rdy = pgrp-&gt;OSFlagFlags &amp; flags;</span><br><span class="line">    <span class="keyword">if</span> (flags_rdy == flags)</span><br><span class="line">    &#123;                                  <span class="comment">//事件标志当前状态与等待条件相符</span></span><br><span class="line">      pgrp-&gt;OSFlagFlags &amp;= ~flags_rdy; <span class="comment">//清除（即“消费”）满足条件的事件标志</span></span><br><span class="line">      flags_cur = pgrp-&gt;OSFlagFlags;</span><br><span class="line">      *err = OS_NO_ERR;</span><br><span class="line">      <span class="keyword">return</span> (flags_cur); <span class="comment">//返回处理后的事件标志组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      OS_FlagBlock(pgrp, &amp;node, flags, wait_type, timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//事件标志当前状态与等待条件不相符，任务被阻塞</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> OS_FLAG_WAIT_SET_ANY: <span class="comment">//任务以“或”方式等待事件标志</span></span><br><span class="line">    flags_rdy = pgrp-&gt;OSFlagFlags &amp; flags;</span><br><span class="line">    <span class="keyword">if</span> (flags_rdy != (OS_FLAGS)<span class="number">0</span>)</span><br><span class="line">    &#123;                                  <span class="comment">//有满足条件的事件标志</span></span><br><span class="line">      pgrp-&gt;OSFlagFlags &amp;= ~flags_rdy; <span class="comment">//清除（即“消费”）满足条件的事件标志</span></span><br><span class="line">      flags_cur = pgrp-&gt;OSFlagFlags;</span><br><span class="line">      *err = OS_NO_ERR;</span><br><span class="line">      <span class="keyword">return</span> (flags_cur); <span class="comment">//返回处理后的事件标志组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      OS_FlagBlock(pgrp, &amp;node, flags, wait_type, timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//事件标志当前状态与等待条件不相符，任务被阻塞</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    flags_cur = (OS_FLAGS)<span class="number">0</span>;</span><br><span class="line">    *err = OS_FLAG_ERR_WAIT_TYPE;</span><br><span class="line">    <span class="keyword">return</span> (flags_cur);</span><br><span class="line">  &#125;</span><br><span class="line">  OS_Sched(); <span class="comment">//当前任务被放到事件标志等待链后，内核实施任务调度</span></span><br><span class="line">              <span class="comment">//这里会退出一段时间再回来</span></span><br><span class="line">  <span class="keyword">if</span> (OSTCBCur-&gt;OSTCBStat &amp; OS_STAT_FLAG)</span><br><span class="line">  &#123;                                    <span class="comment">//判断任务重新就绪的原因，如果是等待超时</span></span><br><span class="line">    OS_FlagUnlink(&amp;node);              <span class="comment">//将任务从事件标志等待链中解除下来</span></span><br><span class="line">    OSTCBCur-&gt;OSTCBStat = OS_STAT_RDY; <span class="comment">//设置当前任务状态为就绪</span></span><br><span class="line">    flags_cur = (OS_FLAGS)<span class="number">0</span>;           <span class="comment">//无效的事件标志状态</span></span><br><span class="line">    *err = OS_TIMEOUT;                 <span class="comment">//超时信号</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;                                                <span class="comment">//任务重新就绪的原因是在限定时间得到了满足条件的事件标志</span></span><br><span class="line">    pgrp-&gt;OSFlagFlags &amp;= ~OSTCBCur-&gt;OSTCBFlagsRdy; <span class="comment">//清除（即“消费”）满足条件的事件标志</span></span><br><span class="line">    flags_cur = pgrp-&gt;OSFlagFlags;</span><br><span class="line">    *err = OS_NO_ERR;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (flags_cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/blog_images/%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%80%9A%E4%BF%A1/OS_TCB%E6%96%B0%E5%BB%BA.png" alt="OS_TCB新建"></p>
<p>将一个空白的OS_TCB填入内容并插入队列中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">OS_FLAGS <span class="title function_">OSFlagAccept</span><span class="params">(OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *err)</span></span><br><span class="line">&#123;</span><br><span class="line">  OS_FLAGS flags_cur, flags_rdy;</span><br><span class="line">  *err = OS_NO_ERR;</span><br><span class="line">  <span class="keyword">switch</span> (wait_type)</span><br><span class="line">  &#123;                          <span class="comment">//判断等待事件标志的方式</span></span><br><span class="line">  <span class="keyword">case</span> OS_FLAG_WAIT_SET_ALL: <span class="comment">//”与”方式等待</span></span><br><span class="line">    flags_rdy = pgrp-&gt;OSFlagFlags &amp; flags;</span><br><span class="line">    <span class="keyword">if</span> (flags_rdy == flags)</span><br><span class="line">      pgrp-&gt;OSFlagFlags &amp;= ~flags_rdy; <span class="comment">//事件标志当前状态与等待条件相符，清除（即“消费”）相应的事件标志</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      *err = OS_FLAG_ERR_NOT_RDY; <span class="comment">//不符合条件，返回错误信息</span></span><br><span class="line">    flags_cur = pgrp-&gt;OSFlagFlags;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> OS_FLAG_WAIT_SET_ANY: <span class="comment">//”或”方式等待</span></span><br><span class="line">    flags_rdy = pgrp-&gt;OSFlagFlags &amp; flags;</span><br><span class="line">    <span class="keyword">if</span> (flags_rdy != (OS_FLAGS)<span class="number">0</span>)</span><br><span class="line">      pgrp-&gt;OSFlagFlags &amp;= ~flags_rdy; <span class="comment">//事件标志当前状态与等待条件相符，清除（即“消费”）相应的事件标志</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      *err = OS_FLAG_ERR_NOT_RDY; <span class="comment">//不符合条件，返回错误信息</span></span><br><span class="line">    flags_cur = pgrp-&gt;OSFlagFlags;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    flags_cur = (OS_FLAGS)<span class="number">0</span>;      <span class="comment">//0表示无效的事件标志组</span></span><br><span class="line">    *err = OS_FLAG_ERR_WAIT_TYPE; <span class="comment">//错误的等待类型</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (flags_cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事件机制的典型应用"><a href="#事件机制的典型应用" class="headerlink" title="事件机制的典型应用"></a>事件机制的典型应用</h3><ol>
<li>发送方（Task1或ISR）发送信息（消息或信号量）；</li>
<li>发送方（Task1或ISR）设置相应的事件标志（指示消息或信号量的发送）</li>
<li>接收方（Task2）检测事件标志集，判断是否满足其接收条件（“与”条件接收或“或”条件接收）</li>
<li>接收方（Task2）根据事件标志集的指示定向接收信息（消息或信号量），达到和不同发送方（Task1或ISR）同步或通信的目的</li>
</ol>
<p>Teak2不能预先知道谁更快发生，Task1发消息还是ISR发信号量</p>
<h2 id="异步信号"><a href="#异步信号" class="headerlink" title="异步信号*"></a>异步信号*</h2><h3 id="异步信号概述"><a href="#异步信号概述" class="headerlink" title="异步信号概述"></a>异步信号概述</h3><p>异步信号机制用于任务与任务之间、任务与ISR之间的<strong>异步操作</strong>，它被任务（或ISR）用来通知其它任务某个事件的出现</p>
<p>异步信号标志依附于任务。需要处理异步信号的任务由<strong>两部分组成</strong>，一个是与异步信号无关的<strong>任务主体</strong>，另一个是ASR（异步信号服务例程）。</p>
<p>一个ASR对应于一个任务。当向任务发送一个异步信号，如果该任务正在运行则中止其自身代码的运行，转而运行与该异步信号相关的服务例程；或者当该任务被激活时，在投入运行前执行ASR。</p>
<p>异步信号机制也可以称作<strong>软中断</strong>机制，异步信号又被称为软中断信号。由软件产生</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">task1 --&gt; a((发送异步信号))</span><br><span class="line">task2 --&gt; a</span><br><span class="line">a --&gt; b1[Task2 使能异步信号]</span><br><span class="line">subgraph Task2函数</span><br><span class="line">    b1---b2</span><br><span class="line">    end</span><br><span class="line">b2[Task2 内容] --&gt; c1[Signal_routine函数]</span><br><span class="line">subgraph Signal_routine函数</span><br><span class="line">c1 --- c2[return]</span><br><span class="line">end</span><br><span class="line">c2 --&gt;b2</span><br><span class="line">c1 --&gt;异步信号标志</span><br></pre></td></tr></table></figure>

<h3 id="异步信号机制与中断机制的比较"><a href="#异步信号机制与中断机制的比较" class="headerlink" title="异步信号机制与中断机制的比较"></a>异步信号机制与中断机制的比较</h3><p>相同点</p>
<ul>
<li>具有中断性。对中断的处理和对异步信号的处理都要先暂时地中断当前任务的运行。<ul>
<li>有相应的服务程序</li>
</ul>
</li>
<li>根据中断向量，有一段与中断信号对应的服务程序，称为ISR（Interrupt Service Routine）<ul>
<li>根据异步信号的编号，有一段与之对应的服务程序，称为ASR（Asynchronious Service Routine）</li>
</ul>
</li>
<li>可以屏蔽其响应<ul>
<li>外部硬件中断可以通过相应的寄存器操作被屏蔽</li>
<li>任务也可屏蔽对异步信号的响应</li>
</ul>
</li>
</ul>
<p>不同点</p>
<ul>
<li><p>实质不同</p>
<ul>
<li>中断由硬件或者特定的指令产生，不受任务调度的控制</li>
<li>异步信号由系统调用（使用发送异步信号功能）产生，受到任务调度的控制</li>
</ul>
</li>
<li><p>处理时机（或响应时间）不同</p>
<ul>
<li>中断触发后，硬件根据中断向量找到相应的服务程序执行。在退出中断服务程序之前会进行重调度，所以中断结束后运行的任务不一定是先前被中断的任务</li>
<li>异步信号通过发送异步信号的系统调用触发，但是系统不一定马上开始对它的处理<ul>
<li>如果接收异步信号的不是当前任务，则ASR要等到接收任务被调度、完成上下文切换后才能执行，之后再执行任务自身的代码</li>
<li>任务也可以给自己发送异步信号，在这种情况下，其ASR将马上执行</li>
</ul>
</li>
</ul>
</li>
<li><p>执行的环境不同</p>
<ul>
<li>一般地，ISR在独立的上下文中运行，操作系统为之提供专门的堆栈空间</li>
<li>ASR在相关任务的上下文中运行，所以ASR也是任务的一个组成部分</li>
</ul>
</li>
</ul>
<h3 id="异步信号机制与事件机制的比较"><a href="#异步信号机制与事件机制的比较" class="headerlink" title="异步信号机制与事件机制的比较"></a>异步信号机制与事件机制的比较</h3><p>同样是标志着某个事件的发生，事件机制的使用是<strong>同步</strong>的（同步信号），而异步信号机制是<strong>异步</strong>的</p>
<ul>
<li>对一个任务来说，什么时候会接收到事件是已知的，因为接收事件的功能是它自己在运行过程中<strong>调用</strong>的</li>
<li>任务<strong>不能预知何时会收到一个异步信号</strong>，并且一旦接收到了异步信号，在允许响应的情况下，它会中断正在运行的代码而去执行异步信号处理程序</li>
</ul>
<h3 id="异步信号机制的主要数据结构"><a href="#异步信号机制的主要数据结构" class="headerlink" title="异步信号机制的主要数据结构"></a>异步信号机制的主要数据结构</h3><p>一种异步信号控制结构Asynchronous_Signal_Control_Block</p>
<ul>
<li>enabled 是否使能对异步信号的响应</li>
<li>handler 处理例程</li>
<li>attribute_set ASR的执行属性<ul>
<li>是否允许任务在执行ASR过程中被抢占</li>
<li>是否允许时间片切换</li>
<li>是否支持ASR嵌套</li>
<li>是否允许在执行ASR过程中响应中断</li>
</ul>
</li>
<li>signals_posted  使能响应时，已发送但尚未处理的信号</li>
<li>signals_pending 屏蔽响应时，已发送但尚未处理的信号</li>
<li>nest_level ASR中异步信号的嵌套层数</li>
</ul>
<h3 id="典型的异步信号操作"><a href="#典型的异步信号操作" class="headerlink" title="典型的异步信号操作"></a>典型的异步信号操作</h3><h4 id="安装异步信号处理例程"><a href="#安装异步信号处理例程" class="headerlink" title="安装异步信号处理例程"></a>安装异步信号处理例程</h4><p>为任务安装一个异步信号处理例程（ASR）。仅当任务已建立了ASR，才允许向该任务发送异步信号，否则发送的异步信号无效。当任务的ASR无效时，发送到任务的异步信号将被丢弃。</p>
<p>调用者需指定ASR的入口地址和执行属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步信号处理例程的一般形式</span></span><br><span class="line"><span class="type">void</span>  <span class="title function_">handler</span><span class="params">(signal_set)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">switch</span>(signal_set)</span><br><span class="line"> &#123;</span><br><span class="line">  CASE SIGNAL_1:</span><br><span class="line">   动作<span class="number">1</span>；</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  CASE SIGNAL_2:</span><br><span class="line">   动作<span class="number">2</span>；</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  ......</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//signal_set参数为任务接收到的异步信号集。</span></span><br></pre></td></tr></table></figure>

<h4 id="发送异步信号到任务"><a href="#发送异步信号到任务" class="headerlink" title="发送异步信号到任务"></a>发送异步信号到任务</h4><ul>
<li>任务或ISR可以调用该功能发送异步信号到目标任务，发送者指定目标任务和要发送的异步信号（集）。</li>
<li>发送异步信号给任务对接收任务的执行状态没有任何影响。</li>
<li>在目标任务已经安装了异步信号处理例程的情况下，如果目标任务不是当前执行任务，则发送给它的异步信号就会等下一次该任务占有处理器时再由相应的ASR处理，任务获得处理器后，将首先执行ASR。</li>
<li>如果当前运行的任务发送异步信号给自己或收到来自中断的异步信号，在允许ASR处理的前提下，它的ASR会立即执行。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/myicon.jpg">
      <meta itemprop="name" content="LinWenXin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of WenXinLin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">内存管理(嵌入式系统与应用)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-14 19:34:31" itemprop="dateCreated datePublished" datetime="2023-11-14T19:34:31+08:00">2023-11-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="内存管理概述"><a href="#内存管理概述" class="headerlink" title="内存管理概述"></a>内存管理概述</h2><h3 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h3><p>定义：把<strong>物理的存储</strong>资源用一定的规则和手段管理起来，以供操作系统和应用程序使用</p>
<p>主要操作：内存块的分配和回收</p>
<p>评价指标：内存利用率、内存块分配和回收的效率、时间确定性</p>
<p>两种分配方法：静态分配和动态分配</p>
<ul>
<li>静态分配简单，但必须事先预知分配的数量（代码大小、数据大小），且缺乏灵活性</li>
<li>动态分配灵活，但会消耗额外的时间和内存开销，可能产生内存碎片</li>
</ul>
<h3 id="通用内存分配"><a href="#通用内存分配" class="headerlink" title="通用内存分配"></a>通用内存分配</h3><p>内存空间划分：代码区，静态数据区和动态数据区</p>
<p>静态分配：发生在编译和链接时，全局变量和静态变量；开始运行就分配，运行结束才释放。</p>
<p>动态分配：发生在程序调入和执行时，局部变量和返回值等；需要时分配，使用完就可以释放。</p>
<ul>
<li>栈：一种线性结构，后进先出，存放函数的参数和返回值、局部变量……</li>
<li>堆：一种链式结构，用于调用malloc和free分配&#x2F;释放的内存。如果调用malloc分配，但缺少调用free释放，会造成内存泄漏。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈内存分配</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">AllocStrFromStack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> pstr[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">return</span> pstr; <span class="comment">//退出释放</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 堆内存分配</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *str; <span class="comment">// 局部变量</span></span><br><span class="line">	<span class="keyword">if</span> ((str = <span class="built_in">malloc</span>(<span class="number">15</span>)) == <span class="literal">NULL</span>) <span class="comment">// 动态分配</span></span><br><span class="line">	&#123;</span><br><span class="line">  		<span class="built_in">printf</span>(<span class="string">&quot;Not enough memory to allocate buffer\n&quot;</span>);</span><br><span class="line">  		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">// 内部处理</span></span><br><span class="line"> 	<span class="built_in">strcpy</span>(str,<span class="string">&quot;hello world&quot;</span>); <span class="comment">//初始化</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;String is %s\n&quot;</span>,str);</span><br><span class="line"> 	<span class="built_in">free</span>(str); <span class="comment">// 释放：指针记录的内容还在</span></span><br><span class="line">	str = <span class="literal">NULL</span>; <span class="comment">// 清楚为空指针，不可用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用malloc()和free()的内存分配特点：</p>
<ul>
<li>需要编译器库提供malloc()和free()函数</li>
<li>执行时间不具有确定性</li>
<li>可能明显增大RTOS内核的代码大小</li>
</ul>
<p>嵌入式实时内核内存管理要求：</p>
<ul>
<li>实时性<ul>
<li>内存分配尽可能快，且具有<strong>确定</strong>性。</li>
</ul>
</li>
<li>可靠性<ul>
<li>内存分配请求必须得到<strong>满足</strong>，否则有严重后果。例如飞机燃油系统的内存分配。</li>
</ul>
</li>
<li>高效性<ul>
<li>内存分配尽可能<strong>减少浪费</strong></li>
</ul>
</li>
</ul>
<p>实时内核所采用的内存管理方式与<strong>应用领域</strong>和<strong>硬件环境</strong>密切相关：</p>
<ul>
<li>在强实时应用领域，内存管理方法就比较简单，甚至不提供内存管理功能</li>
<li>一些实时性要求不高，可靠性要求比较高，且系统比较复杂的应用在内存管理上就相对复杂些，可能需要实现对操作系统或是任务的保护</li>
</ul>
<h3 id="嵌入式实时操作系统在内存管理方面特点"><a href="#嵌入式实时操作系统在内存管理方面特点" class="headerlink" title="嵌入式实时操作系统在内存管理方面特点"></a>嵌入式实时操作系统在内存管理方面特点</h3><ul>
<li>快速而确定的内存管理<ul>
<li><strong>不使用内存管理</strong>：最快速和最确定的内存管理方式，适用于那些小型的嵌入式系统，系统中的任务比较少，且数量固定</li>
<li>通常的操作系统都至少具有<strong>基本的内存管理方法</strong>：提供内存分配与释放的系统调用</li>
</ul>
</li>
<li>不使用虚拟存储技术<ul>
<li>虚拟内存技术：为用户提供一种不受物理存储器结构和容量限制的存储管理技术，每个任务从内存中获得一定数量的页面，并且当前不访问的页面将被置换出去，为需要页面的其他任务腾出空间</li>
<li>置换是一种<strong>具有不确定性</strong>的操作：当任务需要使用当前被置换出去的页面中的代码和数据时，将不得不从磁盘中获取页面，而在内存中另外的页面又可能不得不需要先被置换出去</li>
<li>在嵌入式实时操作系统中一般不使用虚拟存储技术，以<strong>避免页面置换所带来的开销</strong></li>
</ul>
</li>
<li>内存保护<ul>
<li>平面内存模式flat mode<ul>
<li>应用程序和系统程序能够对<strong>整个内存空间</strong>进行访问</li>
<li>平面内存模式比较简单，易于管理，性能也比较高</li>
<li>适合于程序简单、代码量小和实时性要求比较高的领域</li>
</ul>
</li>
<li>内存保护<ul>
<li>应用比较复杂、程序量比较大的情况</li>
<li>防止应用程序破坏操作系统或是其他应用程序的代码和数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="实时内核内存管理机制"><a href="#实时内核内存管理机制" class="headerlink" title="实时内核内存管理机制"></a>实时内核内存管理机制</h2><p>常用内存管理方式：</p>
<ul>
<li>固定大小存储区<ul>
<li>在指定边界的一块地址连续的内存空间中，实现固定大小内存块的分配。</li>
</ul>
</li>
<li>可变大小存储区<ul>
<li>在指定边界的一块地址连续的内存空间中，实现可变大小内存块的分配。</li>
</ul>
</li>
</ul>
<p>应用根据需要从固定大小存储区或者可变大小存储区中获得一块内存空间，用完后将该内存空间释放回相应的存储区。</p>
<h3 id="固定大小存储区管理"><a href="#固定大小存储区管理" class="headerlink" title="固定大小存储区管理"></a>固定大小存储区管理</h3><p>可供使用的一段连续的内存空间被称为是一个分区， 分区由大小固定的内存块构成，且分区的大小是内存块大小的整数倍数<br>一个大小为512字节的分区，内存块为128个字节的分区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     PartitionID           ID;                       <span class="comment">/*分区的ID,ID表示分区的标识*/</span></span><br><span class="line">     PartitionName         Name;                     <span class="comment">/*分区的名字*/</span></span><br><span class="line">     <span class="type">void</span>                 *starting_address;         <span class="comment">/*分区的起始地址*/</span></span><br><span class="line">     <span class="type">int</span>                   length;                   <span class="comment">/*分区的长度,分区的存储单元的数量*/</span></span><br><span class="line">     <span class="type">int</span>                   buffer_size;              <span class="comment">/*内存块的大小*/</span></span><br><span class="line">     PartitionAttribute    attribute;                <span class="comment">/*属性*/</span></span><br><span class="line">     <span class="type">int</span>                   number_of_used_blocks;    <span class="comment">/*剩余内存块数*/</span></span><br><span class="line">     MemoryChain           memory;                   <span class="comment">/*内存块链,一个指针,指向分区中由空闲内存块组成的双向空闲内存块链表的头结点*/</span></span><br><span class="line">&#125;   Partition;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/blog_images/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98%E5%9D%97%E9%93%BE%E8%A1%A8.png" alt="空闲内存块链表"></p>
<p>分区的操作 </p>
<ul>
<li>创建分区</li>
<li>删除分区</li>
<li>从分区得到内存块</li>
<li>把内存块释放到分区</li>
<li>获取分区ID</li>
<li>获取当前创建的分区的数量</li>
<li>获取当前所有分区的ID</li>
<li>获取分区信息</li>
</ul>
<p>如果内存块处于<strong>空闲状态</strong>，内存块中的几个字节将作为控制结构，用来存放用于双向链接的前向指针和后向指针<br>在<strong>使用内存块</strong>时，内存块中原有的控制信息不再有效，其中的所有存储空间都可以被使用<br>固定大小存储区管理的<strong>系统开销</strong>对用户的影响为零，由于内存块的大小固定，不存在<strong>外碎片</strong>的问题<br>但存在<strong>内碎片</strong>的问题</p>
<h3 id="可变大小存储区管理"><a href="#可变大小存储区管理" class="headerlink" title="可变大小存储区管理"></a>可变大小存储区管理</h3><p>一种基于堆的管理方式（与传统堆操作不同）</p>
<ul>
<li>堆为一段连续的、大小可配置的内存空间，用来提供可变内存块的分配。</li>
<li>可变内存块称为段，最小分配单位称为页，即段的大小是页的大小的整数倍。</li>
<li>如果申请段的大小不是页的倍数，实时内核将会对段的大小进行调整，调整为页的倍数。<br>(例如，从页大小为256个字节的堆中分配一个大小为350字节的段，实时内核实际分配的段大小为512个字节)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      HeapID            ID;             	  <span class="comment">/*堆的ID*/</span></span><br><span class="line">      HeadName	        name;          	          <span class="comment">/*堆的名字*/</span></span><br><span class="line">      TaskQueue	        waitQueue; 	          <span class="comment">/*任务等待队列,如果任务从堆中申请段不能得到满足，将被阻塞在堆的等待队列上*/</span></span><br><span class="line">      <span class="type">void</span>              *starting_address;	  <span class="comment">/*内存空间起始地址*/</span></span><br><span class="line">      <span class="type">int</span>               length;		          <span class="comment">/*内存空间长度/字节,堆的大小*/</span></span><br><span class="line">      <span class="type">int</span>               page_size;	          <span class="comment">/*页长度（字节）*/</span></span><br><span class="line">      <span class="type">int</span>               maximum_segment_size;     <span class="comment">/*最大可用段大小*/</span></span><br><span class="line">      RegionAttribute   attribute;                <span class="comment">/*堆的属性*/</span></span><br><span class="line">      <span class="type">int</span>               number_of_used_blocks;    <span class="comment">/*分配的块数,已分配使用的内存块的数量*/</span></span><br><span class="line">      HeapMemoryChain   memory;                   <span class="comment">/*堆头控制结构,空闲段链表*/</span></span><br><span class="line">&#125;Heap; </span><br></pre></td></tr></table></figure>

<ul>
<li>可变大小存储区中的空闲段通过双向链表链接起来，形成一个空闲段链<ul>
<li>在创建堆时，只有一个空闲段，其大小为整个存储区的大小减去控制结构的内存开销</li>
<li>从存储区中分配段时，可依据首次适应算法，查看空闲链中是否存在合适的段</li>
<li>当把段释放回存储区时，该段将被挂在空闲段链的链尾<ul>
<li>如果空闲链中有与该段相邻的段，则将其合并成一个更大的空闲段</li>
<li>由于对申请的内存的大小作了一些限制，避免了内存碎片的产生</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/blog_images/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%A0%86%E7%9A%84%E7%A9%BA%E9%97%B2%E6%AE%B5%E9%93%BE.png" alt="堆的空闲段链"></p>
<p>在段的控制块中设置了一个标志位，表示段被使用的情况：1表示该段正被使用，0表示该段空闲。</p>
<p>在固定大小存储区管理方式中，只有在空闲状态下，内存块才拥有控制信息。在可变大小存储区管理方式中，无论段空闲或是正在被使用，段的控制结构都始终存在。 </p>
<p>堆的操作 </p>
<ul>
<li>创建堆</li>
<li>从堆中得到内存块</li>
<li>释放内存块到堆中</li>
<li>扩展堆</li>
<li>获得已分配内存块的实际可用空间大小</li>
<li>删除堆</li>
<li>获得堆的ID</li>
<li>获得在堆上等待的任务数量</li>
<li>获得等待任务的ID列表</li>
<li>获得堆的数量</li>
<li>获得堆列表</li>
<li>获得堆信息</li>
</ul>
<h3 id="Memory-management-in-uC-OS-II"><a href="#Memory-management-in-uC-OS-II" class="headerlink" title="Memory management in uC&#x2F;OS-II"></a>Memory management in uC&#x2F;OS-II</h3><p><img src="/images/blog_images/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/fixed-sized_memory_blocks_from_a_partition.png" alt="fixed-sized memory blocks from a partition"></p>
<p>内存分区，多内存分区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MEMORY CONTROL BLOCK   MCB    */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* Pointer to beginning of memory partition*/</span></span><br><span class="line">    <span class="type">void</span>   *OSMemAddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pointer to list of free memory blocks   */</span></span><br><span class="line">    <span class="type">void</span>   *OSMemFreeList;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Size (in bytes) of each block of memory */</span>         </span><br><span class="line">    INT32U  OSMemBlkSize; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Total number of blocks in this partition*/</span></span><br><span class="line">    INT32U  OSMemNBlks;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Number of memory blocks remaining in this partition*/</span></span><br><span class="line">    INT32U  OSMemNFree;                </span><br><span class="line">&#125; OS_MEM;</span><br></pre></td></tr></table></figure>

<p><img src="/images/blog_images/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/List_of_free_memory_control_blocks.png" alt="List of free memory control blocks"></p>
<p><em>List of free memory control blocks created by</em> <em>OS_MemInit</em></p>
<p>Each memory control block can be used to manage a partition</p>
<p>每个内存控制块可用于管理一个分区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">OS_MemInit</span> <span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>功能：初始化内存控制块MCB链，形成空闲MCB链表</li>
<li>所在文件os_mem.c</li>
</ul>
<p>创建分区              OSMemCreate</p>
<p>从分区获得内存块      OSMemGet</p>
<p>释放内存块到指定分区  OSMemPut</p>
<p><img src="/images/blog_images/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Partition_created_by_OSMemCreate.png" alt="Partition created by OSMemCreate"></p>
<p>Partition after OSMemGet</p>
<ol>
<li>链首头指向pblk</li>
<li>OSmemFreeList 指向下一块头</li>
</ol>
<p>Partition after OSMemPut</p>
<ol>
<li>链首头指向下一块的头</li>
<li>OSmemFreeList 指向链首</li>
</ol>
<h2 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h2><h3 id="保护内容"><a href="#保护内容" class="headerlink" title="保护内容"></a>保护内容</h3><p>防止地址越界：每个应用程序都有自己独立的地址空间，当应用程序要访问某个内存单元时，由硬件检查该地址是否在限定的地址空间之内，只有在限定地址空间之内的内存单元访问才是合法的，否则需要进行<strong>地址越界</strong>处理</p>
<p>防止操作越权：对于允许多个应用程序共享的存储区域，每个应用程序都有自己的访问权限，如果一个应用程序对共享区域的访问违反了权限规定，则进行<strong>操作越权</strong>处理</p>
<h3 id="保护实现"><a href="#保护实现" class="headerlink" title="保护实现"></a>保护实现</h3><p>内存保护可通过硬件提供的MMU（memory management unit）来实现</p>
<p>早期的嵌入式操作系统大都没有采用MMU：</p>
<ul>
<li>一方面是出于对硬件成本的考虑</li>
<li>另一方面是出于实时性的考虑</li>
</ul>
<p>嵌入式系统发展到现在，硬件成本越来越低，MMU所带来的成本因素基本上可以不用考虑</p>
<p>原来的嵌入式CPU的速度较慢，采用MMU通常会造成对时间性能的不满足，而现在CPU的速度也越来越快，并且采用新技术后，已经将MMU所带来的时间代价降低到比较低的程度</p>
<p>目前，大多数处理器都集成了MMU</p>
<ul>
<li>大幅度<strong>降低</strong>那些通过在处理器外部添加MMU模块的处理方式所存在的<strong>内存访问延迟</strong></li>
<li>MMU现在大都被设计作为处理器内部指令执行<strong>流水线的一部分</strong>，使得使用MMU不会降低系统性能，相反，如果系统软件不使用MMU，还会导致处理器的性能降低</li>
<li>在某些情况下，不使能MMU，跳过处理器的相应流水线，可能导致处理器的性能降低80%左右</li>
</ul>
<p>嵌入式CPU具有MMU的功能已经是一种必要的趋势。</p>
<p>由于采用MMU后对应用的运行模式甚至开发模式都会有一些影响，大量嵌入式操作系统都没有使用MMU</p>
<p>对于安全性、可靠性要求高的应用来讲，如果不采用MMU，则几乎不可能达到应用的要求</p>
<ul>
<li>如果没有MMU的功能，将无法防止程序的无意破坏，无法截获各种非法的访问异常，当然更不可能防止应用程序的蓄意破坏了</li>
<li>采用MMU后，便于发现更多的潜在问题，并且也便于问题的定位<ul>
<li>未采用MMU时，内存模式一般都是平面模式，应用可以任意访问任何内存区域、任何硬件设备，程序中出现非法访问时，开发人员是无从知晓的，也非常难于定位</li>
</ul>
</li>
</ul>
<p>MMU通常具有如下功能 </p>
<ul>
<li><strong>内存映射</strong></li>
<li>检查逻辑地址是否在<strong>限定的地址范围内</strong>，防止页面地址越界</li>
<li>检查对内存页面的访问是否违背<strong>特权信息</strong>，防止越权操作内存页面</li>
<li>在必要的时候（页面地址越界或是页面操作越权）产生<strong>异常</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">程序应用 --&gt;|逻辑地址|MMU</span><br><span class="line">MMU --&gt;|物理地址|物理内存</span><br></pre></td></tr></table></figure>

<p>大多数处理器的典型页面大小为4K字节，有些处理器也可能使用大于4K字节的页面，但<strong>页面大小总是2的幂</strong>，以对发生在MMU中的地址映射行为流水线化</p>
<p>当页放置到物理内存时，页面将放置到<strong>页框架</strong>（page frame）中</p>
<ul>
<li>页框架是物理内存的一部分，具有与页面同样的大小，且开始地址为页面大小的整数倍</li>
<li>MMU包含着能够把逻辑地址映射为物理地址的表，称为<strong>页表</strong><ul>
<li><strong>操作系统</strong>能够在需要的时候对这种映射关系进行改变<ul>
<li>应用程序对内存的需求发生变化或是添加或删除应用程序的时候</li>
<li>在应用程序中的任务发生上下文切换时</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/blog_images/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9F%BA%E4%BA%8E%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E8%BF%87%E7%A8%8B.png" alt="基于页表的内存映射过程"></p>
<p>每个内存页还具有一些特权和状态信息</p>
<ul>
<li>MMU提供二进制位来标识每个页面的特权或状态信息。这些二进制位用来确定页面中的内容是否：<ul>
<li>可被处理器指令所使用（执行特权） </li>
<li>可写（写特权） </li>
<li>可读（读特权） </li>
<li>已被回写（脏位） - 与CACHE配合</li>
<li>当前在物理内存中（有效位）-  虚拟存储</li>
</ul>
</li>
</ul>
<p>在操作系统的支持下，MMU还提供<strong>虚拟存储</strong>功能，即在任务所需要的内存空间超过能够从系统中获得的物理内存空间的情况下，也能够得到正常运行。</p>
<ul>
<li>当需要的页面被添加到逻辑地址空间时，任务对内存页面的合法访问，将自动访问到物理内存</li>
<li>页面当前不在物理内存中时，将导致页面故障异常，然后操作系统负责从后援存储器（如硬盘或是FLASH存储设备）中获取需要的页面，并从产生<strong>页面故障</strong>的机器指令处重新执行</li>
</ul>
<p>MMU通常具有如下不同功能程度的使用方式 </p>
<ul>
<li>0级，内存的平面使用模式<ul>
<li>没有使用MMU，应用程序和系统程序能够对整个内存空间进行访问</li>
<li>采用该模式的系统比较简单、性能也比较高，适合于程序简单、代码量小和实时性要求比较高的领域</li>
<li>大多数<strong>传统的嵌入式操作系统</strong>都采用该模式</li>
</ul>
</li>
<li>1级，处理具有MMU和内存缓存的嵌入式处理器<ul>
<li>通常只是打开MMU，并通过创建一个域（domain，为内存保护的基本单位，每个域对应一个页表）的方式来使用内存，并对每次内存访问执行一些必要的地址转换操作</li>
<li>该模式仍然只是拥有MMU打开特性的平面内存模式</li>
</ul>
</li>
<li>2级，内存保护模式 现代操作系统<ul>
<li>MMU被打开，且创建了静态的域（应用程序的逻辑地址同应用程序在物理内存中的物理地址之间的映射关系在系统运行前就已经确定），以保护应用和操作系统在指针试图访问其他程序的地址空间时不会被非法操作</li>
<li>通常使用消息传送机制实现数据在被MMU保护起来的各个域之间的移动</li>
</ul>
</li>
<li>3级，虚拟内存使用模式<ul>
<li>通过操作系统使用CPU提供的内存映射机制，内存页被动态地分配、释放或是重新分配</li>
<li>从内存映射到基于磁盘的虚拟内存页的过程是透明的</li>
</ul>
</li>
</ul>
<p>区别</p>
<ul>
<li>0级模式为大多数传统嵌入式实时操作系统的使用模式，同1级模式一样，都是内存的平面使用模式，不能实现内存的保护功能</li>
<li>2级模式是目前大多数嵌入式实时操作系统所采用的内存管理模式，既能实现内存保护功能，又能通过静态域的使用方式保证系统的实时特性</li>
<li>3级模式适合于应用比较复杂、程序量比较大，并不要求实时性的应用领域</li>
</ul>
<p><img src="/images/blog_images/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9F%BA%E4%BA%8E%E9%9D%99%E6%80%81%E5%9F%9F%E7%9A%84MMU%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F.png" alt="基于静态域的MMU使用方式"></p>
<p>在这种一一对应的使用方式中，应用程序的逻辑地址同应用程序在物理内存中的物理地址相同，简化了内存管理的实现方式</p>
<p>在嵌入式实时操作系统中，MMU通常被用来进行内存保护</p>
<ul>
<li>实现操作系统与应用程序的隔离</li>
<li>应用程序和应用程序之间的隔离</li>
<li>防止应用程序破坏操作系统的代码、数据以及应用程序对硬件的直接访问</li>
<li>对于应用程序来讲，也可以防止别的应用程序对自己的非法入侵，从而破坏应用程序自身的运行</li>
</ul>
<p>在内存保护方面，MMU提供了以下措施 </p>
<ul>
<li>防止地址越界<ul>
<li>通过限长寄存器检查逻辑地址，确保应用程序只能访问逻辑地址空间所对应的、限定的物理地址空间，MMU将在逻辑地址超越限长寄存器所限定的范围时产生异常</li>
</ul>
</li>
<li>防止操作越权<ul>
<li>根据内存页面的特权信息控制应用程序对内存页面的访问，如果对内存页面的访问违背了内存页面的特权信息，MMU将产生异常</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/23/ros%E6%91%84%E5%83%8F%E5%A4%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/myicon.jpg">
      <meta itemprop="name" content="LinWenXin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of WenXinLin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/23/ros%E6%91%84%E5%83%8F%E5%A4%B4/" class="post-title-link" itemprop="url">Linux-ros安装以及驱动摄像头</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-23 20:13:53" itemprop="dateCreated datePublished" datetime="2023-10-23T20:13:53+08:00">2023-10-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Linux-ros安装以及驱动摄像头"><a href="#Linux-ros安装以及驱动摄像头" class="headerlink" title="Linux-ros安装以及驱动摄像头"></a>Linux-ros安装以及驱动摄像头</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1</span>. sudo apt<span class="literal">-get</span> install ros<span class="literal">-melodic-usb-cam</span>  //melodic是我Linux下ros的版本号，这里根据你安装的ros版本写成对应的</span><br><span class="line"><span class="number">2</span>. roslaunch usb_cam usb_cam<span class="literal">-text</span>.launch</span><br><span class="line"><span class="number">3</span>. rqt_image_view</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>遇到的问题： </p>
<ol>
<li>cannot identity ‘&#x2F;dev&#x2F;vedio0’, 如下<br><img src="/images/blog_images/ros%E6%91%84%E5%83%8F%E5%A4%B4/20200811173924155.png" alt="问题现象"></li>
</ol>
<blockquote>
<p>原因：没有将摄像头链接到虚拟机Linux，这里只要在虚拟机菜单栏找个虚拟机-&gt;可移动设备，将摄像头链接到虚拟机即可，比如：我的电脑的摄像头名称是USB2.0 VGA UVC WebCam，找到之后点击连接到主机，若没有显示摄像头名称则说明你的电脑摄像头不兼容Linux系统，关于如何查看，可打开电脑设备管理器，在照相机的管理列表下则是你电脑的摄像头名称，如下<br><img src="/images/blog_images/ros%E6%91%84%E5%83%8F%E5%A4%B4/20200811174527797.png" alt="信息列表"><br><img src="/images/blog_images/ros%E6%91%84%E5%83%8F%E5%A4%B4/20200811174815599.png" alt="在这里插入图片描述"><br>2. 进程被杀，摄像头灯光亮一下就灭<br><img src="/images/blog_images/ros%E6%91%84%E5%83%8F%E5%A4%B4/20200811175254153.png" alt="在这里插入图片描述"><br>原因：配置太低了，可以到虚拟机-&gt;设置改一下USB控制器的兼容性，改到3.0就可以<img src="/images/blog_images/ros%E6%91%84%E5%83%8F%E5%A4%B4/20200811175521614.png" alt="在这里插入图片描述"><br><img src="/images/blog_images/ros%E6%91%84%E5%83%8F%E5%A4%B4/20200811175546261.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>做到这里，虚拟机下的Linux-ros的摄像头驱动应该就可以跑起来了</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1</span>. roscore //这里第一次跑摄像头驱动最好跑一下master控制节点</span><br><span class="line"><span class="number">2</span>. roslaunch usb_cam usb_cam<span class="literal">-test</span>.launch </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/blog_images/ros%E6%91%84%E5%83%8F%E5%A4%B4/20200811181320598.png" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/23/%E5%9F%BA%E4%BA%8Encurses%E7%9A%84%E8%B4%AA%E5%90%83%E8%9B%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/myicon.jpg">
      <meta itemprop="name" content="LinWenXin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of WenXinLin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/23/%E5%9F%BA%E4%BA%8Encurses%E7%9A%84%E8%B4%AA%E5%90%83%E8%9B%87/" class="post-title-link" itemprop="url">基于linux ncurses的C语言贪吃蛇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-23 20:12:31" itemprop="dateCreated datePublished" datetime="2023-10-23T20:12:31+08:00">2023-10-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="C语言实现贪吃蛇"><a href="#C语言实现贪吃蛇" class="headerlink" title="C语言实现贪吃蛇"></a>C语言实现贪吃蛇</h2><h6 id="对于ncurses库起初完全不熟悉，不知道有那些函数可以调用，在文章的开头先总结一下项目实现过程用到过的函数"><a href="#对于ncurses库起初完全不熟悉，不知道有那些函数可以调用，在文章的开头先总结一下项目实现过程用到过的函数" class="headerlink" title="对于ncurses库起初完全不熟悉，不知道有那些函数可以调用，在文章的开头先总结一下项目实现过程用到过的函数"></a>对于ncurses库起初完全不熟悉，不知道有那些函数可以调用，在文章的开头先总结一下项目实现过程用到过的函数</h6><ul>
<li>initscr(）······· <code> 初始化屏幕</code></li>
<li>raw() ······· <code>设置使所有的输入不需要输入回车就可以传递给程序</code></li>
<li>noecho() ······· <code>设置不回显用户输入内容</code></li>
<li>curs_set(0) ······· <code> 关闭光标显示</code></li>
<li>keypad(stdscr, 1)······· <code>允许用户终端的键盘，允许getch()函数获取功能键</code></li>
<li>nodelay(stdscr, 1) ······· <code> 多线程并发输入，使程序不用一直在getch()等待用户输入</code></li>
<li>refresh() ······· <code> 刷新屏幕，将字符打印屏幕刷新显示</code></li>
<li>endwin()······· <code>结束ncurse屏幕绘画</code></li>
<li>printw() ······· <code> 格式化输出，相当于printf</code></li>
<li>mvprintw ······· <code> 在指定位置格式化输出，前两个参数为屏幕坐标想x, y</code></li>
</ul>
<p>首先定义了蛇的特征，蛇的坐标等结构体，在结构体中包括了蛇的头，蛇的长度，完成时使用到了链表，所以保存了蛇的头，也就可以遍历整条蛇</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*snake coordinate including x,y*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">snake_coordinate</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125; SNAKE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*snake body coordinate struct, to load the snake*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">snake_load</span> &#123;</span></span><br><span class="line">	SNAKE coordinate;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snake_load</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; SNAKE_LOAD;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*snake features including snake_head, and it&#x27;s length*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">snake_features</span> &#123;</span></span><br><span class="line">	SNAKE_LOAD *head;</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">&#125; SNAKE_CREAT;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面是绘制地图的代码，地图格式为x（竖）：22；y（横）：25的大小，因为在linux的终端下横竖的间隔大小不一样，所以在横向上采用两个字符大小的显示空间来显示一个点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*to print the game map*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">map</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">22</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50</span>; j=j+<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			mvprintw(i, j, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">21</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt; <span class="number">48</span>; j=j+<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			mvprintw(i, j, <span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是蛇的打印，过程比较简单，这里就不主要叙述，直接上代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Creat_snake</span><span class="params">(<span class="type">int</span> length)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> located_x = <span class="number">12</span>;</span><br><span class="line">	<span class="type">int</span> located_y = <span class="number">30</span>;</span><br><span class="line">	SNAKE snake;</span><br><span class="line">	snake_wx.length = length;</span><br><span class="line">	SNAKE_LOAD *snake_head_body = (SNAKE_LOAD*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SNAKE_LOAD));</span><br><span class="line">	snake_wx.head = snake_head_body;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; snake_wx.length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		snake.x = located_x;</span><br><span class="line">		snake.y = located_y;</span><br><span class="line">		located_x++;</span><br><span class="line">		SNAKE_LOAD *snake_body = (SNAKE_LOAD*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SNAKE_LOAD));</span><br><span class="line">		snake_head_body-&gt;coordinate = snake;</span><br><span class="line">		snake_head_body-&gt;next = snake_body;</span><br><span class="line">		snake_head_body = snake_body;</span><br><span class="line">	&#125;</span><br><span class="line">	Print_snake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将重点放在最令人头疼的地方，就是创建食物，食物的创建十分讲究，因为它的坐标不能落在蛇身上，也不能落在墙上，后者比较简单，前者难的原因主要在，食物的坐标是通过随机数产生的，产生一次后若刚好在蛇身上，得继续生成一个不在蛇的身上的，起初用到的方法最简单，但也是最难的，哭了，即是一个循环，让它不断产生直到满足条件，这里出现的问题是蛇在移动过程会出现卡顿现象，所以后来修改了另一种方法，第二种方法是如果不满足就继续调用食物创建函数直到满足条件，类似递归，这样做的问题在于会产生段错误，就是在调用rand的时候产生，至今未弄明白是为什么，最后采用了下面这种方法，即如果创建后在蛇身上，即进行加减运算处理，来满足条件，我也不知道还有没有其他的方法，希望有懂的小伙伴一起讨论。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Creat_food</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">	SNAKE_LOAD *snake_head = snake_wx.head;</span><br><span class="line">	srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">	snake_food.x = rand() % <span class="number">19</span>;</span><br><span class="line">	snake_food.y = rand() % <span class="number">23</span>;</span><br><span class="line">	snake_food.y = snake_food.y * <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (snake_food.x &lt; <span class="number">1</span> || snake_food.y &lt; <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (snake_food.x &lt;= <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				snake_food.x = snake_food.x + <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (snake_food.y &lt;= <span class="number">2</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				snake_food.y = snake_food.y * <span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span> (snake_food.y == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					snake_food.y = snake_food.y + <span class="number">2</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		snake_head = snake_wx.head;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; snake_wx.length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (snake_food.x == snake_head-&gt;coordinate.x &amp;&amp; snake_food.y == snake_head-&gt;coordinate.y)</span><br><span class="line">			&#123;</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			snake_head = snake_head-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (key == <span class="number">260</span> || key == <span class="number">261</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (snake_food.x &lt; <span class="number">19</span> &amp;&amp; snake_food.x &gt; <span class="number">5</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					snake_food.x = snake_food.x - <span class="number">2</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (snake_food.x &lt; <span class="number">5</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					snake_food.x = snake_food.x + <span class="number">4</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (key == <span class="number">259</span> || key == <span class="number">258</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (snake_food.y/<span class="number">2</span> &lt; <span class="number">23</span> &amp;&amp; snake_food.y/<span class="number">2</span> &gt; <span class="number">5</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					snake_food.y = (snake_food.y/<span class="number">2</span> - <span class="number">4</span>) * <span class="number">2</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (snake_food.y/<span class="number">2</span> &lt; <span class="number">5</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					snake_food.y = (snake_food.y/<span class="number">2</span> + <span class="number">4</span>) * <span class="number">2</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mvprintw(snake_food.x, snake_food.y, <span class="string">&quot;O&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后还有一个重点的地方就是主函数的getch()获取用户输入，这个函数是会构成等待结果，所以要用nodelay这个函数让它不等待，才可以实现蛇的一直移动</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Main*/</span></span><br><span class="line"><span class="keyword">while</span> ((key = getch()))</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">if</span> (key &gt; <span class="number">0</span>)  <span class="comment">/*keydown*/</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (key == <span class="number">258</span> &amp;&amp; last_key == <span class="number">259</span>)&#123;</span><br><span class="line">				key = <span class="number">259</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (key == <span class="number">259</span> &amp;&amp; last_key == <span class="number">258</span>)&#123;</span><br><span class="line">				key = <span class="number">258</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (key == <span class="number">260</span> &amp;&amp; last_key == <span class="number">261</span>)&#123;</span><br><span class="line">				key = <span class="number">261</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (key == <span class="number">261</span> &amp;&amp; last_key == <span class="number">260</span>)&#123;</span><br><span class="line">				key = <span class="number">260</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			last_key = key;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>	   <span class="comment">/*Don&#x27;t keydown*/</span></span><br><span class="line">		&#123;</span><br><span class="line">			key = last_key;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span>(key)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">258</span>: <span class="comment">//printw(&quot;down\n&quot;);</span></span><br><span class="line">				  down();</span><br><span class="line">				  <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">259</span>: <span class="comment">//printw(&quot;up\n&quot;);</span></span><br><span class="line">				  up();</span><br><span class="line">				  <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">260</span>: <span class="comment">//printw(&quot;left\n&quot;);</span></span><br><span class="line">				  left();</span><br><span class="line">				  <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">261</span>: <span class="comment">//printw(&quot;right\n&quot;);</span></span><br><span class="line">				  right();</span><br><span class="line">				  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (key == <span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (snake_wx.head-&gt;coordinate.x == <span class="number">0</span> || snake_wx.head-&gt;coordinate.y == <span class="number">0</span> || snake_wx.head-&gt;coordinate.x == <span class="number">21</span> || snake_wx.head-&gt;coordinate.y == <span class="number">48</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (snake_wx.head-&gt;coordinate.x == snake_food.x &amp;&amp; snake_wx.head-&gt;coordinate.y == snake_food.y)</span><br><span class="line">		&#123;</span><br><span class="line">			Creat_food();</span><br><span class="line">			Eat_food();</span><br><span class="line">		&#125;</span><br><span class="line">		refresh();</span><br><span class="line">		usleep(<span class="number">120000</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/23/%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/myicon.jpg">
      <meta itemprop="name" content="LinWenXin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of WenXinLin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/23/%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85/" class="post-title-link" itemprop="url">Linux安装arm-linux交叉编译工具链</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-23 20:06:48" itemprop="dateCreated datePublished" datetime="2023-10-23T20:06:48+08:00">2023-10-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/16Ihe11JT6T5wts1FzEtzuQ">https://pan.baidu.com/s/16Ihe11JT6T5wts1FzEtzuQ</a><br>提取码：kplh</p>
</blockquote>
<ol>
<li><p>下载编译工具链，工具链的包我已经放在了百度云盘，具体链接如上，或者可到linaro的官方网站自行下载<a target="_blank" rel="noopener" href="https://releases.linaro.org/components/toolchain/binaries/">https://releases.linaro.org/components/toolchain/binaries/</a></p>
</li>
<li><p>将工具包上传到Linux系统，这里可以通过ftp服务也可以通过安装VMWare tools直接拉拽</p>
</li>
<li><p>将工具链包拷贝到系统目录下，我安装时是拷贝到 &#x2F;usr&#x2F;local&#x2F;arm目录下，以下也是以此目录为例</p>
</li>
<li><p>拷贝到之后通过命令 sudo tar -vxf  gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf.tar进行解压</p>
</li>
<li><p>解压完成后，在&#x2F;usr&#x2F;local&#x2F;arm会看到这样的一个目录<img src="/images/blog_images/%E5%B7%A5%E5%85%B7%E9%93%BE/20200818151609868.png" alt="解压目录"></p>
</li>
<li><p>到这里安装就快完成了，还需到&#x2F;etc&#x2F;profile文件里，添加如下命令设置环境变量：</p>
<pre><code>   export PATH=$PATH:/usr/local/arm/gcc/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin
</code></pre>
</li>
<li><p>最后重启系统，即可</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/23/%E7%94%B5%E6%9C%BA%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/myicon.jpg">
      <meta itemprop="name" content="LinWenXin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of WenXinLin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/23/%E7%94%B5%E6%9C%BA%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">四驱车直流电机驱动</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-23 20:06:16" itemprop="dateCreated datePublished" datetime="2023-10-23T20:06:16+08:00">2023-10-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="四驱车直流马达的使用"><a href="#四驱车直流马达的使用" class="headerlink" title="四驱车直流马达的使用"></a>四驱车直流马达的使用</h2><p>这里我使用的单片机是arduino系列的Wemos D1，它跟带有wifi模块的ESP8266是等同的，具体的模块我也会在之后的文章里继续介绍。之前我在网上看到有教程使用arduino以及它的扩展板AFMotor来驱动直流马达，但是我觉得这样的性价比明显低了，其实可以通过L9110直流电机驱动板来完成，再配合Wemos，也可以做出通过web Sever控制的wifi智能避障小车，下面我先介绍直流马达是如何驱动的。</p>
<h3 id="L9110直流电机驱动板"><a href="#L9110直流电机驱动板" class="headerlink" title="L9110直流电机驱动板"></a>L9110直流电机驱动板</h3><p>  <img src="/images/blog_images/%E7%94%B5%E6%9C%BA%E4%BB%8B%E7%BB%8D/6933743775224.png" alt="驱动板"><br>其实这块板子有一份配置的说明文档，但是我拿到这份说明文档是有错误的，或者可能是跟我入手的这块驱动板不符。它的输入I口有六个，分别是B-1A、B-2A、GND、VCC、A-1A、A-1B，然后VCC是接2.5V-12V电源正极，GND是接电源地，B-1A、B-2A、A-1A、A-1B分别接单片机的IO口，还有O口四个，这四个口没有分编号，而且都顶着一顶绿色帽子，分为两个一组写着MotorA和MotorB，它的接法是将线插到板面的另一侧，然后拧紧上面的螺丝。</p>
<p>根据说明文档<img src="/images/blog_images/%E7%94%B5%E6%9C%BA%E4%BB%8B%E7%BB%8D/20200724162611179.png" alt="文档说明"><br>这里我怀疑说明文档出错了，因为不可能一下子给一个端口配置高电平又低电平，所以我就猜测，一个是IA1-1，IA1-2，一个是IB2-1，一个IB2-2，但是输入端口并没有IA1和IB2这些接角，所以与之对应的可能是上面提到的A-1A、A-1B，B-1A、B-2A。然后配置完后，输出端口OA1 OB1电机正转，刚开始这里我也不太明白，因为按理说输入端与输出端应该是一一对应的，左边I对应左边O，右边I对应右边O，不太可能左边的O与右边的O口，经过我的调试我发现，确实是跟我想的一样，即接到相邻的两个绿端子，如图所示。（注意：是相邻的两个绿端子）<br><img src="/images/blog_images/%E7%94%B5%E6%9C%BA%E4%BB%8B%E7%BB%8D/20200724184558880.png" alt="图片描述"></p>
<h3 id="直流马达电机"><a href="#直流马达电机" class="headerlink" title="直流马达电机"></a>直流马达电机</h3><p><img src="/images/blog_images/%E7%94%B5%E6%9C%BA%E4%BB%8B%E7%BB%8D/20200724182532757.png" alt="马达电机"><br>直流马达没有导线，这里需要用到杜邦线来连接，具体做法可以去百度查看（挺简单的，主要靠动手能力），接完之后把杜邦线另一端接到L9110的绿端子就可以了这里有个问题要说明的是，因为刚开始接完电机动了，但是转轴并不会动，所以我就把电机外壳拆了，发现电机的轴与与齿轮接触不到，之后我把电机顶上去，接触到转轴，就能运转了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/07/web%E6%8E%A7%E5%88%B6arduino/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/myicon.jpg">
      <meta itemprop="name" content="LinWenXin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of WenXinLin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/07/web%E6%8E%A7%E5%88%B6arduino/" class="post-title-link" itemprop="url">通过网页控制Wemos（arduino平台系列）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-07 15:07:47" itemprop="dateCreated datePublished" datetime="2023-10-07T15:07:47+08:00">2023-10-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Wemos-D1的Web-Server服务"><a href="#Wemos-D1的Web-Server服务" class="headerlink" title="Wemos D1的Web Server服务"></a>Wemos D1的Web Server服务</h2><p>这里是通过将客户端、路由器以及Wemos D1组成一个局域网，在此局域网通信，即在客户端的网页通过路由器发送数据到达服务端Wemos D1（此时的Wemos相当于一个服务器），下面将以Wemos控制舵机为例实现Wemos控制万物</p>
<p><strong>案例：Wemos通过网页控制舵机</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Servo.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *ssid = <span class="string">&quot;FAST_C3F6&quot;</span>;	<span class="comment">//家里的wifi名称或者手机热点名称</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *password = <span class="string">&quot;********&quot;</span>;<span class="comment">//家里的wifi密码或者手机热点密码</span></span><br><span class="line"> </span><br><span class="line">WiFiServer <span class="title function_">server</span><span class="params">(<span class="number">80</span>)</span>; <span class="comment">//通过80端口连接到wemos D1</span></span><br><span class="line"> </span><br><span class="line">String readString = <span class="string">&quot;&quot;</span>; <span class="comment">//建立一个字符串对象用来接收存放来自客户的数据</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//响应头</span></span><br><span class="line">String responseHeaders =</span><br><span class="line">    String(<span class="string">&quot;&quot;</span>) +</span><br><span class="line">    <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;Content-Type: text/html\r\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;Connection: close\r\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//网页：HTML+JS的网页，当客户端（即浏览器）发送链接请求时，Wemos则通过路由器发送网页</span></span><br><span class="line">String myhtmlPage =</span><br><span class="line">    String(<span class="string">&quot;&quot;</span>) +</span><br><span class="line">    <span class="string">&quot;&lt;html&gt;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;&lt;head&gt;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;    &lt;title&gt;Wemos D1 Web Server Test&lt;/title&gt;&quot;</span> + </span><br><span class="line">    <span class="string">&quot;    &lt;meta charset = \&quot;UTF-8\&quot;&gt;&quot;</span> + </span><br><span class="line">    <span class="string">&quot;    &lt;script defer=\&quot;defer\&quot;&gt;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;        function ledSwitch() &#123;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;            var xmlhttp;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;            if (window.XMLHttpRequest) &#123;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;                xmlhttp = new XMLHttpRequest();&quot;</span> +</span><br><span class="line">    <span class="string">&quot;            &#125; else &#123;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;                xmlhttp = new ActiveXObject(\&quot;Microsoft.XMLHTTP\&quot;);&quot;</span> +</span><br><span class="line">    <span class="string">&quot;            &#125;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;            xmlhttp.onreadystatechange = function () &#123;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;                if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) &#123;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;                    document.getElementById(\&quot;txtState\&quot;).innerHTML = xmlhttp.responseText;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;                &#125;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;            &#125;,&quot;</span> +</span><br><span class="line">    <span class="string">&quot;            xmlhttp.open(\&quot;GET\&quot;, \&quot;Switch\&quot;, true);&quot;</span> +</span><br><span class="line">    <span class="string">&quot;            xmlhttp.send(); &quot;</span> +</span><br><span class="line">    <span class="string">&quot;        &#125;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;    &lt;/script&gt;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;&lt;/head&gt;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;&lt;body&gt;&lt;center&gt;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;    &lt;div id=\&quot;txtState\&quot;&gt;unknown&lt;/div&gt;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;    &lt;input type=\&quot;button\&quot; value=\&quot;开关\&quot; onclick=\&quot;ledSwitch()\&quot;&gt;&lt;/center&gt;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;&lt;/body&gt;&quot;</span> +</span><br><span class="line">    <span class="string">&quot;&lt;/html&gt;&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">bool</span> isLedTurnOpen = <span class="literal">false</span>; <span class="comment">// 记录舵机状态</span></span><br><span class="line"></span><br><span class="line">Servo myservo;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    myservo.attach(D5);  <span class="comment">//将舵机与D5引脚连接</span></span><br><span class="line">    myservo.write(<span class="number">0</span>);  <span class="comment">//舵机转动0°</span></span><br><span class="line">    </span><br><span class="line">    Serial.begin(<span class="number">115200</span>);  <span class="comment">//启动串口通信，波特率为115200</span></span><br><span class="line">    Serial.println();</span><br><span class="line"> </span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Connecting to %s &quot;</span>, ssid);  <span class="comment">//通过串口在PC打印连接到路由器</span></span><br><span class="line">    WiFi.begin(ssid, password);  <span class="comment">//连接到路由器</span></span><br><span class="line">    <span class="keyword">while</span> (WiFi.status() != WL_CONNECTED)  <span class="comment">//wifi如果没连接成功，则一直在此循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay(<span class="number">500</span>);   </span><br><span class="line">        Serial.print(<span class="string">&quot;.&quot;</span>);  <span class="comment">//每隔0.5s打印一个点.</span></span><br><span class="line">    &#125;</span><br><span class="line">    Serial.println(<span class="string">&quot; connected&quot;</span>);   <span class="comment">//“连接成功”打印</span></span><br><span class="line"> </span><br><span class="line">    server.begin();   <span class="comment">//服务器启动</span></span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Web server started, open %s in a web browser\n&quot;</span>, WiFi.localIP().toString().c_str());    <span class="comment">//打印连接到路由器分配到的ip</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    WiFiClient client = server.available(); <span class="comment">//尝试建立客户对象</span></span><br><span class="line">    <span class="keyword">if</span> (client)                             <span class="comment">//如果当前有客户可用</span></span><br><span class="line">    &#123;</span><br><span class="line">        boolean currentLineIsBlank = <span class="literal">true</span>;</span><br><span class="line">        Serial.println(<span class="string">&quot;[Client connected]&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> (client.connected()) <span class="comment">//如果客户端建立连接</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (client.available()) <span class="comment">//等待有可读数据</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> c = client.read(); <span class="comment">//读取一字节数据</span></span><br><span class="line">                readString += c;        <span class="comment">//拼接数据</span></span><br><span class="line">                <span class="comment">/************************************************/</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) <span class="comment">//等待请求头接收完成(接收到空行)</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//比较接收到的请求数据</span></span><br><span class="line">                    <span class="keyword">if</span> (readString.startsWith(<span class="string">&quot;GET / HTTP/1.1&quot;</span>)) <span class="comment">//如果是网页请求</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        client.print(responseHeaders); <span class="comment">//向客户端输出网页响应</span></span><br><span class="line">                        client.print(myhtmlPage);      <span class="comment">//向客户端输出网页内容</span></span><br><span class="line">                        client.print(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (readString.startsWith(<span class="string">&quot;GET /Switch&quot;</span>)) <span class="comment">//如果是改变舵机状态请求</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (isLedTurnOpen == <span class="literal">false</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            myservo.write(<span class="number">180</span>);</span><br><span class="line">                            client.print(<span class="string">&quot;舵机已经开启，按下可关闭&quot;</span>);</span><br><span class="line">                            isLedTurnOpen = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;  </span><br><span class="line">                            myservo.write(<span class="number">0</span>);</span><br><span class="line">                            client.print(<span class="string">&quot;舵机已经关闭，按下可开启&quot;</span>);</span><br><span class="line">                            isLedTurnOpen = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        client.print(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    currentLineIsBlank = <span class="literal">true</span>; <span class="comment">//开始新行</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    currentLineIsBlank = <span class="literal">false</span>; <span class="comment">//正在接收某行中</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/************************************************/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        delay(<span class="number">1</span>);      <span class="comment">//等待客户完成接收</span></span><br><span class="line">        client.stop(); <span class="comment">//结束当前连接:</span></span><br><span class="line">        Serial.println(<span class="string">&quot;[Client disconnected]&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        Serial.println(readString); <span class="comment">//打印输出来自客户的数据</span></span><br><span class="line">        readString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Wemos通过网页控制万物的基础篇（控制舵机，当然还可以稍微改动，可以控制LED灯，蜂鸣器等），目前在思考控制智能小车的方案，希望可以很快分享出来。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/landscape/page/2/">2</a><a class="extend next" rel="next" href="/landscape/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LinWenXin"
      src="/images/myicon.jpg">
  <p class="site-author-name" itemprop="name">LinWenXin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Linwenxin502" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Linwenxin502" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LinWenXin</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
